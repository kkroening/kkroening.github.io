{"version":3,"sources":["serviceWorker.js","utils.js","Decal.js","BoxDecal.js","CircleDecal.js","LineDecal.js","Frame.js","RotationalFrame.js","daglet.js","Scene.js","Solver.js","TrackFrame.js","Weight.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","ZERO_POS","tf","ZERO_STATE","MissingArgumentError","Error","NotImplementedError","DimensionError","SingularMatrixError","required","name","coercePositionVector","position","data","dataSync","length","reshape","Array","TypeError","coerceStateTuple","state","getScaleMatrix","x","y","undefined","getTranslationMatrix","offset","getRotationTranslationMatrix","angle","c","Math","cos","s","sin","checkXformMatrixShape","mat","toString","shape","getXformMatrixDeterminant","getXformMatrixScaleFactor","sqrt","abs","getXformMatrixRotationAngle","atan2","invertXformMatrix","det","solveLinearSystem","aMat","bVec","asTensor","JSON","stringify","n","qr","qMat","rMat","cVec","transpose","matMul","rArray","arraySync","xArray","i","sum","j","generateRandomId","random","substr","Decal","key","CENTERED_SQUARE","QUAD1_SQUARE","BoxDecal","width","height","centered","solid","lineWidth","color","_cornerPositions","xformMatrix","scale","this","element","cornerPositions","npoints","lines","push","className","x1","y1","x2","y2","strokeWidth","stroke","CircleDecal","radius","xformed","cx","cy","r","fill","LineDecal","endPos","startPos","Frame","decals","weights","frames","resistance","initialState","id","stateMap","has","get","q","getPosMatrix","map","decal","index","getDomElement","frame","RotationalFrame","defaultGetNodeParents","parents","defaultGetNodeKey","toposort","nodes","getNodeParents","getNodeKey","markedNodes","Set","sortedNodes","sortedKeys","unvisitedNodes","visit","node","child","nodeKey","includes","add","forEach","parent","delete","pop","getChildMap","childMap","Map","set","parentKey","transform","visitNode","visitEdge","parentValues","parentNode","parentValue","nodeMap","edgeMap","parentEdgeValues","parentNodeKey","edgeValue","nodeValue","transformNodes","Scene","springs","constraints","gravity","getFrameChildren","getFrameId","sortedFrames","daglet","reverse","frameMap","frameIdParentsMap","values","some","size","frameIdParentMap","frameId","frameIdPathMap","parentPaths","getInitialState","randomize","randPi","PI","Solver","scene","posMatMap","parentId","invPosMatMap","getVelMatrix","getAccelMatrix","velMatMap","velSumMatMap","qd","mul","accelMatMap","accelSumMatMap","parentAccelSumMat","parentVelSumMat","velMat","weight","descendentFrame","ancestorFrame","indexOf","frame1","frame2","_isFrameDescendent","filter","rowIndex","colIndex","weightPosMap","velMat1","velMat2","baseFrame","_getDescendentFrame","descendentFrames","_getDescendentFrames","result","frame3","pos","mass","numFrames","array","columns","_getCoefficientMatrixEntry","externalForceMap","baseVelMat","childFrame","childVelSumMat","childAccelSumMat","weightIndex","weightPos","weightBaseVel","weightChildVelSum","weightChildAccelSum","kineticForce","gravityForce","dragForce","drag","resistanceForce","externalForce","_getForceVectorEntry","_getPosMatMap","_getInvPosMatMap","_getVelMatMap","_getAccelMatMap","_getVelSumMatMap","_getAccelSumMatMap","_getWeightPosMap","_getCoefficientMatrix","_getForceVector","_getSystemOfEquations","deltaTime","qddArray","qdArray","inPlace","newStateMap","qdd","newQ","newQd","_solve","_applyDeltas","qs","qds","solve","sm0","qds0","qdds0","sm1","qds1","qdds1","sm2","qds2","qdds2","sm3","qds3","qdds3","sm4","qds4","qdds4","sm","rungeKutta","doTick","_tickRungeKutta","_tickSimple","bind","TrackFrame","Weight","poi","isLastRopeSegment","segmentIndex","ropeSegmentCount","segments","reduce","childFrames","cart","solver","simulatePhysics","animationDeltaTime","deadline","Date","getTime","tickCount","ceil","timeIndex","console","warn","tick","every","isNaN","isValidStateMap","getInitialStateMap","App","useState","translation","setTranslation","setScale","pressedKeys","callback","setPressedKeys","callbackRef","useRef","current","useEffect","handleKeyDown","code","keyCode","producer","draft","keyName","keyId","pressed","handleKeyUp","addEventListener","removeEventListener","useKeyboard","setStateMap","viewXformMatrix","getViewXformMatrix","fps","React","prevTime","requestRef","timerRef","requestAnimationFrame","animate","time","delay","max","setTimeout","cancelAnimationFrame","clearTimeout","useAnimationFrame","Object","entries","Minus","exp","Equal","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","func","handleViewControls","cartForceValue","KeyA","KeyD","getExternalForceMap","immer","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"qTAYoBA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,mFChBOC,EAAWC,WAAY,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,KAEnCC,GADWD,WAAY,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,KACtB,CAAC,EAAG,IAGjBE,EAAb,wIAA0CC,QAC7BC,EAAb,wIAAyCD,QAC5BE,EAAb,wIAAoCF,QACvBG,EAAb,wIAAyCH,QAElC,SAASI,EAASC,GACvB,MAAM,IAAIN,EAAJ,8CAAgEM,IAGjE,SAASC,IAAuD,IAAlCC,EAAiC,uDAAtBH,EAAS,YAQvD,GAAIG,aAAoBV,SAAW,CACjC,IAAMW,EAAOD,EAASE,WACtB,GAAID,EAAKE,OAAS,GAAKF,EAAKE,OAAS,EACnC,MAAM,IAAIR,EAAJ,kEACyDK,IAGjEA,EAAWV,WAAY,CAACW,EAAK,GAAIA,EAAK,GAAI,IAAIG,QAAQ,CAAC,EAAG,SACrD,GAAIJ,aAAoBK,MAAO,CACpC,GAAIL,EAASG,OAAS,GAAKH,EAASG,OAAS,EAC3C,MAAM,IAAIR,EAAJ,iEACwDK,IAGhEA,EAAWV,WAAY,CAAC,CAACU,EAAS,IAAK,CAACA,EAAS,IAAK,CAAC,SAClD,IAAuB,iBAAZA,EAGhB,MAAM,IAAIM,UAAJ,gFACuEN,IAH7EA,EAAWV,WAAY,CAAC,CAACU,GAAW,CAAC,GAAI,CAAC,KAM5C,OAAOA,EAGF,SAASO,IAA6C,IAA5BC,EAA2B,uDAAnBX,EAAS,SAOhD,GAAa,MAATW,EACFA,EAAQjB,OACH,GAAIiB,IAAUjB,QACd,GAAoB,iBAATiB,EAChBA,EAAQ,CAACA,EAAO,OACX,MAAIA,aAAiBH,OAQ1B,MAAM,IAAIC,UAAJ,yDACgDE,IARtD,GAAqB,IAAjBA,EAAML,QAAgBK,EAAML,OAAS,EACvC,MAAM,IAAIR,EAAJ,oEAC2Da,IAGnEA,EAAQ,CAACA,EAAM,GAAIA,EAAML,OAAS,EAAIK,EAAM,GAAK,GAMnD,OAAOA,EAGF,SAASC,IAAkD,IAAnCC,EAAkC,uDAA9Bb,EAAS,KAAMc,EAAe,4DAAXC,EAIpD,OAHS,MAALD,IACFA,EAAID,GAECpB,WAAY,CACjB,CAACoB,EAAG,EAAG,GACP,CAAC,EAAGC,EAAG,GACP,CAAC,EAAG,EAAG,KAcJ,SAASE,IAAmD,IAA9BC,EAA6B,uDAApBjB,EAAS,UAErD,OADAiB,EAASf,EAAqBe,GAAQZ,WAC/BZ,WAAY,CACjB,CAAC,EAAG,EAAGwB,EAAO,IACd,CAAC,EAAG,EAAGA,EAAO,IACd,CAAC,EAAG,EAAGA,EAAO,MAIX,SAASC,IAGb,IAFDC,EAEA,uDAFQnB,EAAS,SACjBiB,EACA,uDADSjB,EAAS,UAElBiB,EAASf,EAAqBe,GAAQZ,WACtC,IAAMe,EAAIC,KAAKC,IAAIH,GACbI,EAAIF,KAAKG,IAAIL,GACnB,OAAO1B,WAAY,CACjB,CAAC2B,GAAIG,EAAGN,EAAO,IACf,CAACM,EAAGH,EAAGH,EAAO,IACd,CAAC,EAAG,EAAGA,EAAO,MAIX,SAASQ,IAA8C,IAAxBC,EAAuB,uDAAjB1B,EAAS,OACnD,KAAM0B,aAAejC,UACnB,MAAM,IAAIgB,UAAJ,6EACoEiB,EAAIC,aAGhF,GAAyB,IAArBD,EAAIE,MAAMtB,QAAiC,IAAjBoB,EAAIE,MAAM,IAA6B,IAAjBF,EAAIE,MAAM,GAC5D,MAAM,IAAI9B,EAAJ,yEACgE4B,EAAIC,aAKvE,SAASE,IAAkD,IAAxBH,EAAuB,uDAAjB1B,EAAS,OACvDyB,EAAsBC,GACtB,IAAMtB,EAAOsB,EAAIrB,WACjB,OAAOD,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAGrC,SAAS0B,IAAkD,IAAxBJ,EAAuB,uDAAjB1B,EAAS,OACvD,OAAOqB,KAAKU,KAAKV,KAAKW,IAAIH,EAA0BH,KAG/C,SAASO,IAAoD,IAAxBP,EAAuB,uDAAjB1B,EAAS,OACzDyB,EAAsBC,GACtB,IAAMtB,EAAOsB,EAAIrB,WACjB,OAAOgB,KAAKa,MAAM9B,EAAK,IAAKA,EAAK,IAS5B,SAAS+B,IAA0C,IAAxBT,EAAuB,uDAAjB1B,EAAS,OAI/CyB,EAAsBC,GACtB,IAAMtB,EAAOsB,EAAIrB,WACX+B,EACJhC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GACzBA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GACzBA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GACzBA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GACzBA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GACzBA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAC3B,OAAOX,WAAY,CACjB,GACIW,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,IACzChC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,IACzChC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,GAE7C,GACIhC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,IACzChC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,IACzChC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,GAE7C,GACIhC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,IACzChC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,IACzChC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAAMgC,KAK1C,SAASC,IAIb,IAHDC,EAGA,uDAHOtC,EAAS,QAChBuC,EAEA,uDAFOvC,EAAS,QAEhB,yDADsB,GACtB,IADEwC,gBACF,SAKA,KAAMF,aAAgB7C,UACpB,MAAM,IAAIgB,UAAJ,wDAC+C6B,IAEhD,KAAMC,aAAgB9C,UAC3B,MAAM,IAAIgB,UAAJ,wDAC+C8B,IAEhD,GAA0B,IAAtBD,EAAKV,MAAMtB,QAAgBgC,EAAKV,MAAM,KAAOU,EAAKV,MAAM,GACjE,MAAM,IAAI9B,EACR,sFAC2B2C,KAAKC,UAAUJ,EAAKV,SAE5C,GAA0B,IAAtBW,EAAKX,MAAMtB,QAAkC,IAAlBiC,EAAKX,MAAM,GAC/C,MAAM,IAAI9B,EACR,sGAC2B2C,KAAKC,UAAUH,EAAKX,SAE5C,GAAIU,EAAKV,MAAM,KAAOW,EAAKX,MAAM,GACtC,MAAM,IAAI9B,EACR,kFACoB2C,KAAKC,UAAUJ,EAAKV,OADxC,8BAEoBa,KAAKC,UAAUH,EAAKX,SAQ5C,IALA,IAAMe,EAAIJ,EAAKX,MAAM,GA9BrB,EA+BqBnC,SAAUmD,GAAGN,GA/BlC,mBA+BOO,EA/BP,KA+BaC,EA/Bb,KAgCMC,EAAOF,EAAKG,YAAYC,OAAOV,GAAMlC,WACrC6C,EAASJ,EAAKK,YACdC,EAAS5C,MAAMmC,GACZU,EAAIV,EAAI,EAAGU,GAAK,EAAGA,IAAK,CAC/B,GAAIhC,KAAKW,IAAIkB,EAAOG,GAAGA,IA9NM,KA+N3B,MAAM,IAAItD,EAAJ,2BAA4CuC,EAAKX,aAGzD,IADA,IAAI2B,EAAM,EACDC,EAAIF,EAAI,EAAGE,EAAIZ,EAAGY,IACzBD,GAAOJ,EAAOG,GAAGE,GAAKH,EAAOG,GAE/BH,EAAOC,IAAMN,EAAKM,GAAKC,GAAOJ,EAAOG,GAAGA,GAE1C,OAAOb,EAAW/C,WAAY2D,GAAQ7C,QAAQ,CAACoC,EAAG,IAAMS,EAWnD,SAASI,IAGd,OAAOnC,KAAKoC,SAAS9B,SAAS,IAAI+B,OAAO,EAAG,G,ICvPzBC,E,gGAC0B,2CAAzB3D,EAAS,eAC3B,MAAM,IAAIH,EAAoB,qB,sCAM9B,2CAFcG,EAAS,eAEtB,IAAD,yDADsB,GACtB,EADE4D,IAEF,MAAM,IAAI/D,EAAoB,uB,sBCD5BgE,EAAkBpE,WACZ,CACR,EAAE,IAAM,GAAK,GACb,CAAC,IAAM,GAAK,GACZ,CAAC,GAAK,GAAK,GACX,EAAE,GAAK,GAAK,KAEbuD,YAEGc,EAAerE,WACT,CACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KAERuD,YAEkBe,E,kDACnB,aASS,IAAD,2DAAJ,GAAI,IARNC,aAQM,MARE,EAQF,MAPNC,cAOM,MAPG,EAOH,MANN9D,gBAMM,MANKX,EAML,MALN2B,aAKM,MALE,EAKF,MAJN+C,gBAIM,aAHNC,aAGM,aAFNC,iBAEM,MAFM,EAEN,MADNC,aACM,MADE,QACF,8BACN,gBACKL,MAAQA,EACb,EAAKC,OAASA,EACd,EAAK9D,SAAWD,EAAqBC,GACrC,EAAKgB,MAAQA,EACb,EAAK+C,WAAaA,EAClB,EAAKC,QAAUA,EACf,EAAKC,UAAYA,EACjB,EAAKC,MAAQA,EACb,EAAKC,iBAAmBpD,GAA8BC,EAAO,EAAKhB,UAC/D8C,OAAOrC,EAAeoD,EAAOC,IAC7BhB,OAAOiB,EAAWL,EAAkBC,GAZjC,E,oDAesC,IAAxCS,EAAuC,uDAAzBvE,EAAS,eACrBwE,EAAQ1C,EAA0ByC,GACxC,OAAO,IAAIR,EAAS,CAClBC,MAAOS,KAAKT,MAAQQ,EACpBP,OAAQQ,KAAKR,OAASO,EACtBrE,SAAUoE,EAAYtB,OAAOwB,KAAKtE,UAClCgB,MAAOsD,KAAKtD,MAAQc,EAA4BsC,GAChDL,SAAUO,KAAKP,SACfC,MAAOM,KAAKN,MACZC,UAAWK,KAAKL,UAAYI,EAC5BH,MAAOI,KAAKJ,U,sCAOb,IACGK,EAHJH,EAEA,uDAFcvE,EAAS,eAEvB,yDADsB,GACtB,IADE4D,WACF,WADQ7C,EACR,EAEMyD,EAAQ1C,EAA0ByC,GAClCI,EAAkBJ,EAAYtB,OAAOwB,KAAKH,kBAAkBnB,YAClE,GAAIsB,KAAKN,MACPO,EACE,0BACE7D,EAAG8D,EAAgB,GAAG,GACtB7D,EAAG6D,EAAgB,GAAG,GACtBX,MAAOS,KAAKT,MAAQQ,EACpBP,OAAQQ,KAAKR,OAASO,EACtBZ,IAAKA,QAGJ,CAGL,IAFA,IAAMgB,EAAUH,KAAKH,iBAAiB1C,MAAM,GACtCiD,EAAQ,GACLxB,EAAI,EAAGA,EAAIuB,EAASvB,IAAK,CAChC,IAAME,GAAKF,EAAI,GAAKuB,EACpBC,EAAMC,KACJ,0BACEC,UAAU,aACVC,GAAIL,EAAgB,GAAGtB,GACvB4B,GAAIN,EAAgB,GAAGtB,GACvB6B,GAAIP,EAAgB,GAAGpB,GACvB4B,GAAIR,EAAgB,GAAGpB,GACvB6B,YAAaX,KAAKL,UAAYI,EAC9Ba,OAAQZ,KAAKJ,MACbT,IAAKP,KAIXqB,EAAU,uBAAGd,IAAKA,GAAMiB,GAE1B,OAAOH,M,GA5E2Bf,GCtBjB2B,E,kDACnB,aAAwE,IAAD,2DAAJ,GAAI,IAAzDnF,gBAAyD,MAA9CX,EAA8C,MAApC+F,cAAoC,MAA3B,EAA2B,MAAxBlB,aAAwB,MAAhB,QAAgB,8BACrE,gBACKlE,SAAWD,EAAqBC,GACrC,EAAKoF,OAASA,EACd,EAAKlB,MAAQA,EAJwD,E,oDAOzB,IAAxCE,EAAuC,uDAAzBvE,EAAS,eACrBwE,EAAQ1C,EAA0ByC,GACxC,OAAOe,EAAY,CACjBnF,SAAUoE,EAAYtB,OAAOwB,KAAKtE,UAClCoF,OAAQd,KAAKc,OAASf,M,sCAOvB,IAFDD,EAEA,uDAFcvE,EAAS,eAEvB,yDADsB,GACtB,IADE4D,WACF,WADQ7C,EACR,EACMyE,EAAUjB,EAAYtB,OAAOwB,KAAKtE,UAAUE,WAC5CmE,EAAQ1C,EAA0ByC,GACxC,OACE,4BACEQ,UAAU,eACVU,GAAID,EAAQ,GACZE,GAAIF,EAAQ,GACZG,EAAGlB,KAAKc,OAASf,EACjBoB,KAAMnB,KAAKJ,MACXT,IAAKA,Q,GA7B4BD,GCApBkC,E,kDACnB,aAKS,IAAD,2DAAJ,GAAI,IAJNC,cAIM,MAJG9F,EAAS,UAIZ,MAHN+F,gBAGM,MAHKvG,EAGL,MAFN4E,iBAEM,MAFM,EAEN,MADNC,aACM,MADE,QACF,8BACN,gBACK0B,SAAW7F,EAAqB6F,GACrC,EAAKD,OAAS5F,EAAqB4F,GACnC,EAAK1B,UAAYA,EACjB,EAAKC,MAAQA,EALP,E,oDAQsC,IAAxCE,EAAuC,uDAAzBvE,EAAS,eACrBwE,EAAQ1C,EAA0ByC,GACxC,OAAOsB,EAAU,CACfC,OAAQvB,EAAYtB,OAAOwB,KAAKqB,QAChCC,SAAUxB,EAAYtB,OAAOwB,KAAKsB,UAClC3B,UAAWK,KAAKL,UAAYI,EAC5BH,MAAOI,KAAKJ,U,sCAOb,IAFDE,EAEA,uDAFcvE,EAAS,eAEvB,yDADsB,GACtB,IADE4D,WACF,WADQ7C,EACR,EACMgF,EAAWxB,EAAYtB,OAAOwB,KAAKsB,UAAU1F,WAC7CyF,EAASvB,EAAYtB,OAAOwB,KAAKqB,QAAQzF,WACzCmE,EAAQ1C,EAA0ByC,GACxC,OACE,0BACEQ,UAAU,aACVC,GAAIe,EAAS,GACbd,GAAIc,EAAS,GACbb,GAAIY,EAAO,GACXX,GAAIW,EAAO,GACXV,YAAaX,KAAKL,UAAYI,EAC9Ba,OAAQZ,KAAKJ,MACbT,IAAKA,Q,GAxC0BD,GCElBqC,E,WACnB,aAQS,IAAD,yDAAJ,GAAI,IAPN7F,gBAOM,MAPKX,EAOL,MANNyG,cAMM,MANG,GAMH,MALNC,eAKM,MALI,GAKJ,MAJNC,cAIM,MAJG,GAIH,MAHNC,kBAGM,MAHO,EAGP,MAFNC,oBAEM,MAFS3G,EAET,MADN4G,UACM,MADD,KACC,sBACN7B,KAAK6B,GAAW,MAANA,EAAaA,EAAK9C,IAC5BiB,KAAKtE,SAAWD,EAAqBC,GACrCsE,KAAKwB,OAASA,EACdxB,KAAKyB,QAAUA,EACfzB,KAAK0B,OAASA,EACd1B,KAAK2B,WAAaA,EAClB3B,KAAK4B,aAAe3F,EAAiB2F,G,2DAGP,2CAAfrG,EAAS,KACxB,OAAOP,MAAO,K,qCAGgB,2CAAfO,EAAS,KACxB,OAAOP,QAAS,CAAC,EAAG,M,uCAGY,2CAAfO,EAAS,KAC1B,OAAOP,QAAS,CAAC,EAAG,M,sCAOnB,IAHD8G,EAGA,uDAHWvG,EAAS,YACpBuE,EAEA,uDAFcvE,EAAS,eAEvB,yDADsB,GACtB,IADE4D,WACF,WADQ7C,EACR,IACYwF,EAASC,IAAI/B,KAAK6B,IAAMC,EAASE,IAAIhC,KAAK6B,IAAM5G,EAD5D,mBACOgH,EADP,KAGA,OADAnC,EAAcA,EAAYtB,OAAOwB,KAAKkC,aAAaD,IAEjD,uBAAG3B,UAAU,QAAQnB,IAAKA,GACvBa,KAAKwB,OAAOW,KAAI,SAACC,EAAOC,GAAR,OACfD,EAAME,cAAcxC,EAAa,CAAEX,IAAK,QAAUkD,OAEnDrC,KAAK0B,OAAOS,KAAI,SAACI,EAAOF,GAAR,OACfE,EAAMD,cAAcR,EAAUhC,EAAa,CAAEX,IAAK,QAAUkD,Y,KC/CjDG,E,kDACnB,aAQS,IAAD,yDAAJ,GAAI,IAPN9G,gBAOM,MAPKX,EAOL,MANNyG,cAMM,MANG,GAMH,MALNC,eAKM,MALI,GAKJ,MAJNC,cAIM,MAJG,GAIH,MAHNC,kBAGM,MAHO,EAGP,MAFNC,oBAEM,MAFS3G,EAET,MADN4G,UACM,MADD,KACC,yCACA,CACJnG,SAAUA,EACV8F,OAAQA,EACRC,QAASA,EACTC,OAAQA,EACRC,WAAYA,EACZC,aAAcA,EACdC,GAAIA,I,oDAOL,IAFD/B,EAEA,uDAFcvE,EAAS,eAEvB,yDADkE,GAClE,IADEiG,cACF,WADWlF,EACX,MADsBmF,eACtB,WADgCnF,EAChC,MAD2CoF,cAC3C,WADoDpF,EACpD,EACA,OAAO,IAAIkG,EAAgB,CACzB9G,SAAUoE,EAAYtB,OAAOwB,KAAKtE,UAClC8F,OAAkB,MAAVA,EAAiBA,EAASxB,KAAKwB,OACvCC,QAAoB,MAAXA,EAAkBA,EAAUzB,KAAKyB,QAC1CC,OAAkB,MAAVA,EAAiBA,EAAS1B,KAAK0B,OACvCC,WAAY3B,KAAK2B,WACjBC,aAAc5B,KAAK4B,iB,qCAIU,IAApBK,EAAmB,uDAAf1G,EAAS,KAClBG,EAAWsE,KAAKtE,SAASE,WACzBe,EAAIC,KAAKC,IAAIoF,GACbnF,EAAIF,KAAKG,IAAIkF,GACnB,OAAOjH,WAAY,CACjB,CAAC2B,GAAIG,EAAGpB,EAAS,IACjB,CAACoB,EAAGH,EAAGjB,EAAS,IAChB,CAAC,EAAG,EAAG,O,qCAIsB,IAApBuG,EAAmB,uDAAf1G,EAAS,KAClBoB,EAAIC,KAAKC,IAAIoF,GACbnF,EAAIF,KAAKG,IAAIkF,GACnB,OAAOjH,WAAY,CACjB,EAAE8B,GAAIH,EAAG,GACT,CAACA,GAAIG,EAAG,GACR,CAAC,EAAG,EAAG,O,uCAIwB,IAApBmF,EAAmB,uDAAf1G,EAAS,KACpBoB,EAAIC,KAAKC,IAAIoF,GACbnF,EAAIF,KAAKG,IAAIkF,GACnB,OAAOjH,WAAY,CACjB,EAAE2B,EAAGG,EAAG,GACR,EAAEA,GAAIH,EAAG,GACT,CAAC,EAAG,EAAG,S,GA9DgC4E,GCNhCkB,EAAwB,SAACrG,GAAD,OAAOA,EAAEsG,SACjCC,EAAoB,SAACvG,GAAD,OAAOA,GAEjC,SAASwG,EACdC,GAEC,IAAD,yDADyD,GACzD,IADEC,sBACF,WADmBxG,EACnB,MAD8ByG,kBAC9B,WAD2CzG,EAC3C,EACAwG,EAAiBA,GAAkBL,EACnCM,EAAaA,GAAcJ,EAC3B,IAAMK,EAAc,IAAIC,IAClBC,EAAc,GACdC,EAAa,GACbC,EAAc,YAAOP,GAE3B,SAASQ,EAAMC,EAAMC,GACnB,IAAMC,EAAUT,EAAWO,GAC3B,GAAIN,EAAYjB,IAAIyB,GAClB,MAAM,IAAIrI,MAAJ,sDAAyDmI,IAEjE,IAAKH,EAAWM,SAASD,GAAU,CACjC,IAAMd,EAAUI,EAAeQ,GAC3BZ,IACFM,EAAYU,IAAIF,GAChBd,EAAQiB,SAAQ,SAACC,GAAD,OAAYP,EAAMO,EAAQN,MAC1CN,EAAYa,OAAOL,GACnBN,EAAY7C,KAAKiD,GACjBH,EAAW9C,KAAKmD,KAKtB,KAAOJ,EAAevH,QAAQ,CAC5B,IAAMyH,EAAOF,EAAeU,MAC5BT,EAAMC,GAER,OAAOJ,EAGF,SAASa,EACdlB,GAEC,IAAD,yDADyD,GACzD,IADEC,sBACF,WADmBxG,EACnB,MAD8ByG,kBAC9B,WAD2CzG,EAC3C,EAGM4G,EAAcN,EAASC,EAAO,CAClCC,eAHFA,EAAiBA,GAAkBL,EAIjCM,WAHFA,EAAaA,GAAcJ,IAKrBqB,EAAW,IAAIC,IAWrB,OAVAf,EAAYS,SAAQ,SAACL,GACnB,IAAME,EAAUT,EAAWO,GACrBZ,EAAUI,EAAeQ,GAC/BU,EAASjC,IAAIyB,IAAYQ,EAASE,IAAIV,EAAS,IAAIP,KACnDP,EAAQiB,SAAQ,SAACC,GACf,IAAMO,EAAYpB,EAAWa,GAC7BI,EAASjC,IAAIoC,IAAcH,EAASE,IAAIC,EAAW,IAAIlB,KACvDe,EAAShC,IAAImC,GAAWT,IAAIJ,SAGzBU,EAGF,SAASI,EACdvB,GAOC,IAAD,yDADI,GACJ,IALEC,sBAKF,WALmBxG,EAKnB,MAJEyG,kBAIF,WAJezG,EAIf,MAHE+H,iBAGF,WAHc/H,EAGd,MAFEgI,iBAEF,WAFchI,EAEd,EAGA+H,EAAYA,GAAc,SAACf,EAAMiB,GAAP,OAAwB,MAClDD,EAAYA,GAAc,SAAChB,EAAMkB,EAAYC,GAAnB,OAAmCA,GAC7D,IAAMvB,EAAcN,EAASC,EAAO,CAClCC,eALFA,EAAiBA,GAAkBL,EAMjCM,WALFA,EAAaA,GAAcJ,IAOrB+B,EAAU,IAAIT,IACdU,EAAU,IAAIV,IAapB,OAZAf,EAAYS,SAAQ,SAACL,GACnB,IAAME,EAAUT,EAAWO,GAErBsB,EADc9B,EAAeQ,GACEnB,KAAI,SAACqC,GACxC,IAAMK,EAAgB9B,EAAWyB,GAC3BM,EAAYR,EAAUhB,EAAMkB,EAAYE,EAAQ1C,IAAI6C,IAE1D,OADAF,EAAQT,IAAI,CAACW,EAAerB,GAAUsB,GAC/BA,KAEHC,EAAYV,EAAUf,EAAMsB,GAClCF,EAAQR,IAAIV,EAASuB,MAEhB,CAACL,EAASC,GAGZ,SAASK,EACdnC,GAMC,IAAD,yDADI,GACJ,IAJEC,sBAIF,WAJmBxG,EAInB,MAHEyG,kBAGF,WAHezG,EAGf,MAFE+H,iBAEF,WAFc/H,EAEd,IACkB8H,EAAUvB,EAAO,CACjCC,eAAgBA,EAChBC,WAAYA,EACZsB,UAAWA,IAJb,mBACOK,EADP,KAMA,OAAOA,ECxGF,IAEcO,E,WACnB,aAMS,IAAD,yDAAJ,GAAI,IALNzD,cAKM,MALG,GAKH,MAJNE,cAIM,MAJG,GAIH,MAHNwD,eAGM,MAHI,GAGJ,MAFNC,mBAEM,MAFQ,GAER,MADNC,eACM,MATqB,GASrB,sBACNpF,KAAKwB,OAASA,EACdxB,KAAK0B,OAASA,EACd1B,KAAKkF,QAAUA,EACflF,KAAKmF,YAAcA,EACnBnF,KAAKoF,QAAUA,EAEf,IAAMC,EAAmB,SAAC9C,GAAD,OAAWA,EAAMb,QACpC4D,EAAa,SAAC/C,GAAD,OAAWA,EAAMV,IACpC7B,KAAKuF,aAAeC,EACRxF,KAAK0B,OAAQ,CACrBoB,eAAgBuC,EAChBtC,WAAYuC,IAEbG,UACHzF,KAAK0F,SAAW,IAAIzB,IAClBjE,KAAKuF,aAAapD,KAAI,SAACI,GAAD,MAAW,CAACA,EAAMV,GAAIU,OAE9C,IAAMoD,EAAoBH,EAAmBxF,KAAKuF,aAAc,CAC9DzC,eAAgBuC,EAChBtC,WAAYuC,IAEd,GAAI,YAAIK,EAAkBC,UAAUC,MAAK,SAACnD,GAAD,OAAaA,EAAQoD,KAAO,KACnE,MAAM,IAAI3K,MAAM,sCAElB6E,KAAK+F,iBAAmB,IAAI9B,IAC1B,YAAI0B,GAAmBxD,KAAI,mCAAE6D,EAAF,KAAWtD,EAAX,WAAwB,CACjDsD,EACAtD,EAAQoD,KAAO,YAAIpD,GAAS,GAAGb,GAAK,UAGxC7B,KAAKiG,eAAiBT,EAAsBxF,KAAKuF,aAAc,CAC7DzC,eAAgB,SAACP,GAAD,mBAAeoD,EAAkB3D,IAAIO,EAAMV,MAC3DkB,WAAYuC,EACZjB,UAAW,SAAC9B,EAAO2D,GAAR,OACTA,EAAYrK,OAAZ,sBAAyBqK,EAAY,IAArC,CAAyC3D,EAAMV,KAAM,CAACU,EAAMV,O,4DAQ/D,IAHDC,EAGA,uDAHWvG,EAAS,YACpBuE,EAEA,uDAFc9E,MAAO,GAErB,yDADsB,GACtB,IADEmE,WACF,WADQ7C,EACR,EACA,OACE,uBAAGgE,UAAU,QAAQnB,IAAKA,GACvBa,KAAKwB,OAAOW,KAAI,SAACC,EAAOC,GAAR,OACfD,EAAME,cAAcxC,EAAa,CAAEX,IAAK,QAAUkD,OAEnDrC,KAAK0B,OAAOS,KAAI,SAACI,EAAOF,GAAR,OACfE,EAAMD,cAAcR,EAAUhC,EAAa,CAAEX,IAAK,QAAUkD,U,2CAMpB,IAC1C8D,EADyC,yDAAJ,GAAI,IAA1BC,iBAA0B,SAE7C,GAAIA,EAAW,CACb,IAAMC,EAAS,kBAAOzJ,KAAKoC,SAAW,IAAOpC,KAAK0J,GAAK,GACvDH,EAAkB,SAAC5D,GAAD,MAAW,CAAC8D,IAAUA,WAExCF,EAAkB,SAAC5D,GAAD,OAAWA,EAAMX,cAErC,OAAO,IAAIqC,IACTjE,KAAKuF,aAAapD,KAAI,SAACI,GAAD,MAAW,CAACA,EAAMV,GAAIsE,EAAgB5D,Y,aC1E7CgE,E,WACnB,aAAwC,IAA5BC,EAA2B,uDAAnBjL,EAAS,SAAU,oBACrCyE,KAAKwG,MAAQA,E,4DAGiC,IAAD,EAAjC1E,EAAiC,uDAAtBvG,EAAS,YAK1BkL,EAAY,IAAIxC,IALuB,cAM3BjE,KAAKwG,MAAMjB,cANgB,IAM7C,2BAA2C,CAAC,IAAnChD,EAAkC,UAC7BT,EAASE,IAAIO,EAAMV,IADU,mBAClCI,EADkC,KAEnCyE,EAAW1G,KAAKwG,MAAMT,iBAAiB/D,IAAIO,EAAMV,IACnD5E,EAAMsF,EAAML,aAAaD,GACzByE,IACFzJ,EAAMwJ,EAAUzE,IAAI0E,GAAUlI,OAAOvB,IAEvCwJ,EAAUvC,IAAI3B,EAAMV,GAAI5E,IAbmB,8BAe7C,OAAOwJ,I,yCAG4C,IAApCA,EAAmC,uDAAvBlL,EAAS,aAKpC,OAAO,IAAI0I,IACT,YAAIwC,GAAWtE,KAAI,yCAAuB,CAAvB,KAEjBzE,EAFiB,a,sCAWpB,IAAD,OAHA+I,EAGA,uDAHYlL,EAAS,aACrBoL,EAEA,uDAFepL,EAAS,gBACxBuG,EACA,uDADWvG,EAAS,YASpB,OAAO,IAAI0I,IACTjE,KAAKwG,MAAMjB,aAAapD,KAAI,SAACI,GAAW,IAAD,EACzBT,EAASE,IAAIO,EAAMV,IAAxBI,EAD8B,oBAE/ByE,EAAW,EAAKF,MAAMT,iBAAiB/D,IAAIO,EAAMV,IACnD5E,EAAMsF,EAAMqE,aAAa3E,GAAGzD,OAAOmI,EAAa3E,IAAIO,EAAMV,KAI9D,OAHI6E,IACFzJ,EAAMwJ,EAAUzE,IAAI0E,GAAUlI,OAAOvB,IAEhC,CAACsF,EAAMV,GAAI5E,S,wCASrB,IAAD,OAHAwJ,EAGA,uDAHYlL,EAAS,aACrBoL,EAEA,uDAFepL,EAAS,gBACxBuG,EACA,uDADWvG,EAAS,YAOpB,OAAO,IAAI0I,IACTjE,KAAKwG,MAAMjB,aAAapD,KAAI,SAACI,GAAW,IAAD,EACzBT,EAASE,IAAIO,EAAMV,IAAxBI,EAD8B,oBAE/ByE,EAAW,EAAKF,MAAMT,iBAAiB/D,IAAIO,EAAMV,IACnD5E,EAAMsF,EAAMsE,eAAe5E,GAAGzD,OAAOmI,EAAa3E,IAAIO,EAAMV,KAIhE,OAHI6E,IACFzJ,EAAMwJ,EAAUzE,IAAI0E,GAAUlI,OAAOvB,IAEhC,CAACsF,EAAMV,GAAI5E,S,yCAStB,2CAHY1B,EAAS,aAGpB,IAAD,EAFAuL,EAEA,uDAFYvL,EAAS,aACrBuG,EACA,uDADWvG,EAAS,YAEdwL,EAAe,IAAI9C,IADzB,cAEkBjE,KAAKwG,MAAMjB,cAF7B,IAEA,2BAA2C,CAAC,IAAnChD,EAAkC,UAC1BT,EAASE,IAAIO,EAAMV,IADO,mBAChCmF,EADgC,KAEnCN,EAAW1G,KAAKwG,MAAMT,iBAAiB/D,IAAIO,EAAMV,IACnD5E,EAAM6J,EAAU9E,IAAIO,EAAMV,IAAIoF,IAAID,GAClCN,IACFzJ,EAAMA,EAAIyG,IAAIqD,EAAa/E,IAAI0E,KAEjCK,EAAa7C,IAAI3B,EAAMV,GAAI5E,IAT7B,8BAWA,OAAO8J,I,2CASP,2CALYxL,EAAS,aAKpB,IAAD,EAJAuL,EAIA,uDAJYvL,EAAS,aACrB2L,EAGA,uDAHc3L,EAAS,eACvBwL,EAEA,uDAFexL,EAAS,gBACxBuG,EACA,uDADWvG,EAAS,YAEd4L,EAAiB,IAAIlD,IAD3B,cAEkBjE,KAAKwG,MAAMjB,cAF7B,IAEA,2BAA2C,CAAC,IAAnChD,EAAkC,UAC1BT,EAASE,IAAIO,EAAMV,IADO,mBAChCmF,EADgC,KAEnCN,EAAW1G,KAAKwG,MAAMT,iBAAiB/D,IAAIO,EAAMV,IACnD5E,EAAMiK,EAAYlF,IAAIO,EAAMV,IAAIoF,IAAID,EAAKA,GAC7C,GAAIN,EAAU,CACZ,IAAMU,EAAoBD,EAAenF,IAAI0E,GACvCW,EAAkBN,EAAa/E,IAAI0E,GACnCY,EAASR,EAAU9E,IAAIO,EAAMV,IACnC5E,EAAMA,EACHyG,IAAI0D,GACJ1D,IAAI2D,EAAgB7I,OAAO8I,GAAQL,IAAI,EAAID,IAEhDG,EAAejD,IAAI3B,EAAMV,GAAI5E,IAd/B,8BAgBA,OAAOkK,I,yCAG4C,IAApCV,EAAmC,uDAAvBlL,EAAS,aAKpC,OAAO,IAAI0I,IACTjE,KAAKwG,MAAMjB,aAAapD,KAAI,SAACI,GAAD,MAAW,CACrCA,EAAMV,GACNU,EAAMd,QAAQU,KAAI,SAACoF,GAAD,OAChBd,EAAUzE,IAAIO,EAAMV,IAAIrD,OAAO+I,EAAO7L,oB,2CAS3C,IAFD8L,EAEA,uDAFkBjM,EAAS,mBAC3BkM,EACA,uDADgBlM,EAAS,iBAEzB,OAGoC,IAFlCyE,KAAKwG,MAAMP,eACRjE,IAAIwF,EAAgB3F,IACpB6F,QAAQD,EAAc5F,M,4CAO1B,IAFD8F,EAEA,uDAFSpM,EAAS,UAClBqM,EACA,uDADSrM,EAAS,UAUlB,OAPIyE,KAAK6H,mBAAmBF,EAAQC,GACrBD,EACJ3H,KAAK6H,mBAAmBD,EAAQD,GAC5BC,EAEA,O,6CAKgD,IAAD,OAA3CH,EAA2C,uDAA3BlM,EAAS,iBAC5C,OAAOyE,KAAKwG,MAAMjB,aAAauC,QAAO,SAACvF,GAAD,OACpC,EAAKsF,mBAAmBtF,EAAOkF,Q,mDAShC,IAAD,EAJAM,EAIA,uDAJWxM,EAAS,YACpByM,EAGA,uDAHWzM,EAAS,YACpBuL,EAEA,uDAFYvL,EAAS,aACrB0M,EACA,uDADe1M,EAAS,gBAElBoM,EAAS3H,KAAKwG,MAAMjB,aAAawC,GACjCH,EAAS5H,KAAKwG,MAAMjB,aAAayC,GACjCE,EAAUpB,EAAU9E,IAAI2F,EAAO9F,IAC/BsG,EAAUrB,EAAU9E,IAAI4F,EAAO/F,IAC/BuG,EAAYpI,KAAKqI,oBAAoBV,EAAQC,GAC7CU,EAAmBF,EACrBpI,KAAKuI,qBAAqBH,GAC1B,GACAI,EAAS,EATb,cAUmBF,GAVnB,IAUA,2BACE,IADoC,IAA7BG,EAA4B,QAC1BpG,EAAQ,EAAGA,EAAQoG,EAAOhH,QAAQ5F,OAAQwG,IAAS,CAC1D,IAAMkF,EAASkB,EAAOhH,QAAQY,GACxBqG,EAAMT,EAAajG,IAAIyG,EAAO5G,IAAIQ,GACxCmG,GACEjB,EAAOoB,KACP3N,SACUmN,EAAQ3J,OAAOkK,GAAMR,EAAQ1J,OAAOkK,IAAM,GACjD9M,WAAW,IAlBpB,8BAqBA,OAAO4M,I,8CASP,IAHC,IAFD1B,EAEA,uDAFYvL,EAAS,aACrB0M,EACA,uDADe1M,EAAS,gBAElBqN,EAAY5I,KAAKwG,MAAMjB,aAAa1J,OACpCgN,EAAQ9M,MAAM6M,GACXb,EAAW,EAAGA,EAAWa,EAAWb,IAAY,CAEvD,IADA,IAAMe,EAAU/M,MAAM6M,GACbZ,EAAW,EAAGA,EAAWY,EAAWZ,IAC3Cc,EAAQd,GAAYhI,KAAK+I,2BACvBhB,EACAC,EACAlB,EACAmB,GAGJY,EAAMd,GAAYe,EAEpB,OAAO9N,WAAY6N,K,6CAWlB,IAAD,EAPAT,EAOA,uDAPY7M,EAAS,aACrBuL,EAMA,uDANYvL,EAAS,aACrBwL,EAKA,uDALexL,EAAS,gBACxB4L,EAIA,uDAJiB5L,EAAS,kBAC1B0M,EAGA,uDAHe1M,EAAS,gBACxBuG,EAEA,uDAFWvG,EAAS,YACpByN,EACA,uDADmBzN,EAAS,oBAExBiN,EAAS,EACPS,EAAanC,EAAU9E,IAAIoG,EAAUvG,IAF3C,cAGuB7B,KAAKuI,qBAAqBH,IAHjD,IAGA,2BAA6D,CAG3D,IAH4D,IAArDc,EAAoD,QACrDC,EAAiBpC,EAAa/E,IAAIkH,EAAWrH,IAC7CuH,EAAmBjC,EAAenF,IAAIkH,EAAWrH,IAEjDwH,EAAc,EAClBA,EAAcH,EAAWzH,QAAQ5F,OACjCwN,IACA,CACA,IAAM9B,EAAS2B,EAAWzH,QAAQ4H,GAC5BC,EAAYrB,EAAajG,IAAIkH,EAAWrH,IAAIwH,GAC5CE,EAAgBN,EAAWzK,OAAO8K,GAClCE,EAAoBL,EAAe3K,OAAO8K,GAC1CG,EAAsBL,EAAiB5K,OAAO8K,GAC9CI,GACHnC,EAAOoB,KACRY,EAAc/K,OAAOiL,GAAqB,GAAM7N,WAAW,GACvD+N,GACHpC,EAAOoB,KAAO3I,KAAKwG,MAAMpB,QAAUmE,EAAc3N,WAAW,GACzDgO,GACHrC,EAAOsC,KACRN,EAAc/K,OAAOgL,GAAmB,GAAM5N,WAAW,GAC3D4M,EAASkB,EAAeE,EAAYD,EArBqB,MAuB5C7H,EAASE,IAAIoG,EAAUvG,IAvBqB,mBAuBlDmF,EAvBkD,KAwBrD8C,GAAmB1B,EAAUzG,WAAaqF,EAC1C+C,EACHf,GAAoBA,EAAiBhH,IAAIoG,EAAUvG,KAAQ,EAC9D2G,GAAUuB,EAAgBD,GA9B5B,8BAgCA,OAAOtB,I,wCAaP,IAHC,IAND1B,EAMA,uDANYvL,EAAS,aACrBwL,EAKA,uDALexL,EAAS,gBACxB4L,EAIA,uDAJiB5L,EAAS,kBAC1B0M,EAGA,uDAHe1M,EAAS,gBACxBuG,EAEA,uDAFWvG,EAAS,YACpByN,EACA,uDADmBzN,EAAS,oBAEtBqN,EAAY5I,KAAKwG,MAAMjB,aAAa1J,OACpCgN,EAAQ9M,MAAM6M,GACXvG,EAAQ,EAAGA,EAAQuG,EAAWvG,IACrCwG,EAAMxG,GAASrC,KAAKgK,qBAClBhK,KAAKwG,MAAMjB,aAAalD,GACxByE,EACAC,EACAI,EACAc,EACAnG,EACAkH,GAGJ,OAAOhO,WAAY6N,GAAO/M,QAAQ,CAAC8M,EAAW,M,8CAM7C,IAFD9G,EAEA,uDAFWvG,EAAS,YACpByN,EACA,uDADmBzN,EAAS,oBAEtBkL,EAAYzG,KAAKiK,cAAcnI,GAC/B6E,EAAe3G,KAAKkK,iBAAiBzD,GACrCK,EAAY9G,KAAKmK,cAAc1D,EAAWE,EAAc7E,GACxDoF,EAAclH,KAAKoK,gBAAgB3D,EAAWE,EAAc7E,GAC5DiF,EAAe/G,KAAKqK,iBAAiB5D,EAAWK,EAAWhF,GAC3DqF,EAAiBnH,KAAKsK,mBAC1B7D,EACAK,EACAI,EACAH,EACAjF,GAEImG,EAAejI,KAAKuK,iBAAiB9D,GACrC5I,EAAOmC,KAAKwK,sBAAsB1D,EAAWmB,GAC7CnK,EAAOkC,KAAKyK,gBAChB3D,EACAC,EACAI,EACAc,EACAnG,EACAkH,GAEF,MAAO,CAACnL,EAAMC,K,+BAMb,IAFDgE,EAEA,uDAFWvG,EAAS,YACpByN,EACA,uDADmBzN,EAAS,oBAC5B,EACqByE,KAAK0K,sBAAsB5I,EAAUkH,GAD1D,mBACOnL,EADP,KACaC,EADb,KAEA,OAAOF,EAAkBC,EAAMC,EAAM,CAAEC,UAAU,M,qCAShD,IALD+D,EAKA,uDALWvG,EAAS,YACpBoP,EAIA,uDAJYpP,EAAS,aACrBqP,EAGA,uDAHWrP,EAAS,YACpBsP,EAEA,4DAFUvO,EAEV,yDADsB,GACtB,IADEwO,eACF,SACMC,EAAcD,EAAUhJ,EAAW,IAAImC,IAC9B,MAAX4G,IACFA,EAAU,YAAI/I,GAAUK,KAAI,qFAE9B,IAAK,IAAIE,EAAQ,EAAGA,EAAQrC,KAAKwG,MAAMjB,aAAa1J,OAAQwG,IAAS,CACnE,IAAME,EAAQvC,KAAKwG,MAAMjB,aAAalD,GAD6B,EAEvDP,EAASE,IAAIO,EAAMV,IAFoC,mBAE5DI,EAF4D,KAG7D+E,EAAK6D,EAAQxI,GACb2I,EAAMJ,EAASvI,GACf4I,EAAOhJ,EAAI+E,EAAK2D,EAChBO,EAAQlE,EAAKgE,EAAML,EACzBI,EAAY7G,IAAI3B,EAAMV,GAAI,CAACoJ,EAAMC,IAEnC,OAAOH,I,oCAON,IAHDjJ,EAGA,uDAHWvG,EAAS,YACpBoP,EAEA,uDAFYpP,EAAS,aACrByN,EACA,uDADmBzN,EAAS,oBAEtBqP,EAAW5K,KAAKmL,OAAOrJ,EAAUkH,GACvC,OAAOhJ,KAAKoL,aAAatJ,EAAU6I,EAAWC,K,sCAGW,IAA7CS,EAA4C,uDAAvC9P,EAAS,MAAO+P,EAAuB,uDAAjB/P,EAAS,OAChD,OAAO,IAAI0I,IACTjE,KAAKwG,MAAMjB,aAAapD,KAAI,SAACI,EAAOF,GAAR,MAAkB,CAC5CE,EAAMV,GACN,CAACwJ,EAAGhJ,GAAQiJ,EAAIjJ,W,wCASnB,IAAD,OAHAP,EAGA,uDAHWvG,EAAS,YACpBoP,EAEA,uDAFYpP,EAAS,aACrByN,EACA,uDADmBzN,EAAS,oBAEtBgQ,EAAQ,SAACzJ,GAAD,OAAc,EAAKqJ,OAAOrJ,EAAUkH,IAE5CwC,EAAM1J,EACN2J,EAAO,YAAID,GAAKrJ,KAAI,oFACpBuJ,EAAQH,EAAMC,GAEdG,EAAM3L,KAAKoL,aAAaI,EAAKb,EAAY,EAAGe,EAAOD,GACnDG,EAAO,YAAID,GAAKxJ,KAAI,oFACpB0J,EAAQN,EAAMI,GAEdG,EAAM9L,KAAKoL,aAAaI,EAAKb,EAAY,EAAGkB,EAAOD,GACnDG,EAAO,YAAID,GAAK3J,KAAI,oFACpB6J,EAAQT,EAAMO,GAEdG,EAAMjM,KAAKoL,aAAaI,EAAKb,EAAY,EAAGqB,EAAOD,GACnDG,EAAO,YAAID,GAAK9J,KAAI,oFACpBgK,EAAQZ,EAAMU,GAEdG,EAAMpM,KAAKoL,aAAaI,EAAKb,EAAWwB,EAAOD,GAC/CG,EAAO,YAAID,GAAKjK,KAAI,oFACpBmK,EAAQf,EAAMa,GAEhBG,EAAKf,EAKT,OAJAe,EAAKvM,KAAKoL,aAAamB,EAAI5B,EAAY,EAAGkB,EAAOD,GACjDW,EAAKvM,KAAKoL,aAAamB,EAAI5B,EAAY,EAAGqB,EAAOD,GACjDQ,EAAKvM,KAAKoL,aAAamB,EAAI5B,EAAY,EAAGwB,EAAOD,GACjDK,EAAKvM,KAAKoL,aAAamB,EAAI5B,EAAY,EAAG2B,EAAOD,K,6BAShD,IAJDvK,EAIA,uDAJWvG,EAAS,YACpBoP,EAGA,uDAHYpP,EAAS,aACrByN,EAEA,uDAFmB,KAEnB,yDADyB,GACzB,IADEwD,kBACF,SACMC,EAASD,EAAaxM,KAAK0M,gBAAkB1M,KAAK2M,YACxD,OAAOF,EAAOG,KAAK5M,KAAZyM,CAAkB3K,EAAU6I,EAAW3B,O,KCxZ7B6D,E,kDACnB,aASS,IAAD,2DAAJ,GAAI,IARNnR,gBAQM,MARKX,EAQL,MAPN2B,aAOM,MAPE,EAOF,MANN8E,cAMM,MANG,GAMH,MALNC,eAKM,MALI,GAKJ,MAJNC,cAIM,MAJG,GAIH,MAHNC,kBAGM,MAHO,EAGP,MAFNC,oBAEM,MAFS3G,EAET,MADN4G,UACM,WADDvF,EACC,8BACN,cAAM,CACJI,MAAOA,EACP8E,OAAQA,EACRC,QAASA,EACTC,OAAQA,EACRC,WAAYA,EACZC,aAAcA,EACdlG,SAAUA,EACVmG,GAAIA,KAEDnF,MAAQA,EAXP,E,oDAiBL,IAFDoD,EAEA,uDAFcvE,EAAS,eAEvB,yDADkE,GAClE,IADEiG,cACF,WADWlF,EACX,MADsBmF,eACtB,WADgCnF,EAChC,MAD2CoF,cAC3C,WADoDpF,EACpD,EACA,OAAO,IAAIuQ,EAAW,CACpBnR,SAAUoE,EAAYtB,OAAOwB,KAAKtE,UAClCgB,MAAOsD,KAAKtD,MAAQc,EAA4BsC,GAChD0B,OAAkB,MAAVA,EAAiBA,EAASxB,KAAKwB,OACvCC,QAAoB,MAAXA,EAAkBA,EAAUzB,KAAKyB,QAC1CC,OAAkB,MAAVA,EAAiBA,EAAS1B,KAAK0B,OACvCC,WAAY3B,KAAK2B,WACjBC,aAAc5B,KAAK4B,iB,qCAIU,IAApBK,EAAmB,uDAAf1G,EAAS,KAClBG,EAAWsE,KAAKtE,SAASE,WAC/B,OAAOW,EAAqB,CAC1Bb,EAAS,GAAKuG,EAAIrF,KAAKC,IAAImD,KAAKtD,OAChChB,EAAS,GAAKuG,EAAIrF,KAAKG,IAAIiD,KAAKtD,W,qCAIJ,2CAAfnB,EAAS,KACxB,OAAOP,WAAY,CACjB,CAAC,EAAG,EAAG4B,KAAKC,IAAImD,KAAKtD,QACrB,CAAC,EAAG,EAAGE,KAAKG,IAAIiD,KAAKtD,QACrB,CAAC,EAAG,EAAG,S,GAnD2B6E,GCLnBuL,E,WACnB,aAA+D,IAAnDnE,EAAkD,uDAA3C,EAA2C,yDAAJ,GAAI,IAAtCjN,gBAAsC,MAA3BX,EAA2B,MAAjB8O,YAAiB,MAAV,EAAU,sBAC5D7J,KAAK2I,KAAOA,EACZ3I,KAAKtE,SAAWD,EAAqBC,GACrCsE,KAAK6J,KAAOA,E,kDAGR/J,GACJ,OAAO,IAAIgN,EAAO,CAChBnE,KAAM3I,KAAK2I,KACXjN,SAAUoE,EAAYtB,OAAOwB,KAAKtE,UAClCmO,KAAM7J,KAAK6J,W,KCmBXkD,EAAM,IAAIvK,EAAgB,CAC9BX,GAAI,MACJD,aAAc,CAAC,EAAG,GAClBJ,OAAQ,CACN,IAAIJ,EAAU,CAAEC,OAAQ,CAjBF,EAiBsB,GAAI1B,UAAW,KAC3D,IAAIkB,EAAY,CACdnF,SAAU,CAnBU,EAmBU,GAC9BoF,OAAQ,KAGZpF,SAAU,CAvBc,EAuBM,GAC9B+F,QAAS,CACP,IAAIqL,EA3BQ,GA2BQ,CAAEpR,SAAU,CAzBV,EAyB8B,GAAImO,KA1B5C,MA4BdlI,WAxB4B,KA2BxBqL,EAAoB,SAACC,GAAD,OACPC,IAAjBD,GAEIE,GAAWpR,MAAMmR,GACpB/L,OACAgB,KAAI,SAAC/F,EAAGiG,GAAJ,OAAcA,KAClB+K,QACC,SAACC,EAAahL,GAAd,MAAwB,CACtB,IAAIG,EAAgB,CAClBX,GAAG,UAAD,OAAYQ,GACdT,aAAcoL,EAAkB3K,GAAS,EAAY,GAAXzF,KAAK0J,GAAW,GAAK,CAAC,EAAG,GACnE9E,OAAQ,CACN,IAAIJ,EAAU,CAAEC,OAAQ,CA1CR,EA0C4B,GAAI1B,UAAW,KAC3D,IAAIkB,EAAY,CACdnF,SAAU,CA5CI,EA4CgB,GAC9BoF,OAAQ,MAGZY,OAAQ2L,EACR3R,SAAUsR,EAAkB3K,GAAS,CAAC,EAAG,GAAK,CAjD5B,EAiDgD,GAClEZ,QAAS,CACP,IAAIqL,EAjDU,EAiDc,CAC1BpR,SAAU,CApDI,EAoDgB,GAC9BmO,KApDY,KAuDhBlI,WArDsB,QAwD1B,CAACoL,IAGCO,GAAO,IAAIT,EAAW,CAC1BhL,GAAI,OACJL,OAAQ,CACN,IAAIlC,EAAS,CACXC,MAAO,EACPC,OAAQ,EAAI,MAEZG,UAAW,MAGf+B,OAAQyL,GACR1L,QAAS,CAAC,IAAIqL,EAAO,MACrBnL,WApEqB,IAuEjB6E,GAAQ,IAAIvB,EAAM,CACtBvD,OAAQ,CAAC4L,IACT9L,OAAQ,CACN,IAAIJ,EAAU,CACZE,SAAU,EAAE,IAAK,GACjBD,OAAQ,CAAC,IAAK,GACdzB,MAAO,OACPD,UAAW,QAIX4N,GAAS,IAAIhH,EAAOC,IAgH1B,SAASgH,GAAgB1L,EAAUkH,EAAkByE,GAKnD,IAJA,IACMC,GADY,IAAIC,MAAOC,UACA,IACvBC,EAAYjR,KAAKkR,KAhME,IAgMwBL,GAC3C9C,EAAY8C,EAAqBI,EAC9BE,EAAY,EAAGA,EAAYF,EAAWE,IAAa,CAC1D,IAAI,IAAIJ,MAAOC,UAAYF,EAAU,CACnCM,QAAQC,KACN,iEACcJ,EAAYE,EAD1B,WAGF,MAEFjM,EAAWyL,GAAOW,KAAKpM,EAAU6I,EAAW3B,EAAkB,CAC5DwD,YA/Ma,IAwNjB,OA1DF,SAAyB1K,GACvB,OAAO,YAAIA,GAAUqM,OAAM,gEAAYlM,EAAZ,KAAe+E,EAAf,YAAyBoH,MAAMnM,KAAOmM,MAAMpH,MAmDlEqH,CAAgBvM,KACnBkM,QAAQC,KACN,gEAEFnM,EAAW0E,GAAM8H,sBAEZxM,EAkDMyM,OAzCf,WAAgB,IAAD,EACyBC,mBAAS,CAAC,EAAG,IADtC,mBACNC,EADM,KACOC,EADP,OAEaF,mBAAS,IAFtB,mBAENzO,EAFM,KAEC4O,EAFD,KAGPC,EAjJR,SAAqBC,GAAW,IAAD,EACSL,mBAAS,IAAIvL,KADtB,mBACtB2L,EADsB,KACTE,EADS,KAEvBC,EAAcC,mBA6CpB,OA5CAD,EAAYE,QAAUJ,EAEtBK,qBAAU,WACR,SAASC,EAAT,GAA2C,IAAlBC,EAAiB,EAAjBA,KAAMC,EAAW,EAAXA,QAC7BP,GAAe,SAACF,GAYd,OAXKA,EAAY7M,IAAIqN,KACnBR,EAAcU,YAASV,GAAa,SAACW,GACnCA,EAAM7L,IAAI0L,MAEZL,EAAYE,SACVF,EAAYE,QAAQ,CAClBO,QAASJ,EACTK,MAAOJ,EACPK,SAAS,KAGRd,KAGX,SAASe,EAAT,GAAyC,IAAlBP,EAAiB,EAAjBA,KAAMC,EAAW,EAAXA,QAC3BP,GAAe,SAACF,GAYd,OAXIA,EAAY7M,IAAIqN,KAClBR,EAAcU,YAASV,GAAa,SAACW,GACnCA,EAAM1L,OAAOuL,MAEfL,EAAYE,SACVF,EAAYE,QAAQ,CAClBO,QAASJ,EACTK,MAAOJ,EACPK,SAAS,KAGRd,KAMX,OAFAjU,OAAOiV,iBAAiB,UAAWT,GACnCxU,OAAOiV,iBAAiB,QAASD,GAC1B,WACLhV,OAAOkV,oBAAoB,UAAWV,GACtCxU,OAAOkV,oBAAoB,QAASF,MAErC,IAEIf,EAkGakB,GAHP,EAImBtB,mBAAShI,GAAM8H,sBAJlC,mBAINxM,EAJM,KAIIiO,EAJJ,KAKPC,EAXR,SAA4BvB,EAAa1O,GACvC,OAAOxD,EAAqB,CAAC,IAAK,MAC/BiC,OAAOrC,EAAe4D,GAAQA,IAC9BvB,OAAOjC,EAAqBkS,IAQPwB,CAAmBxB,EAAa1O,GAgBxD,OAjHwB,SAAC8O,GAAmD,IAAD,yDAAP,GAAO,IAAtCqB,WAAsC,MAlIhD,GAkIgD,EACrEhU,EAAQiU,IAAMnB,OAAO,CAAEoB,SAAU,IACjCC,EAAaF,IAAMnB,SACnBsB,EAAWH,IAAMnB,SACvB9S,EAAM+S,QAAQJ,SAAWA,EAEzBsB,IAAMjB,WAAU,WAYd,OADAmB,EAAWpB,QAAUsB,uBAVrB,SAASC,EAAQC,GACf,IAAM9F,GAAa8F,EAAOvU,EAAM+S,QAAQmB,UAAY,IAC9CM,EAAQ9T,KAAK+T,IAAI,IAAOT,EAAMvF,EAAW,GAC/CzO,EAAM+S,QAAQJ,SAASlE,GACvBzO,EAAM+S,QAAQmB,SAAWK,EACzBH,EAASrB,QAAU2B,YAAW,WAC5BP,EAAWpB,QAAUsB,sBAAsBC,KAC1CE,MAIE,WACLG,qBAAqBR,EAAWpB,SAChCqB,EAASrB,SAAW6B,aAAaR,EAASrB,YAE3C,CAACiB,IA6EJa,EAAkB,SAACpG,IAtErB,SACEiE,EACAjE,EACA5K,EACA0O,EACAE,EACAD,GAEAsC,OAAOC,QAAQ,CACbC,MAAO,kBAAMvC,EAAS5O,EAAQnD,KAAKuU,KAAKxG,KACxCyG,MAAO,kBAAMzC,EAAS5O,EAAQnD,KAAKuU,IAAIxG,KACvC0G,UAAW,kBAAM3C,GAAe,mCAAEtS,EAAF,KAAKC,EAAL,WAAY,CAACD,EAAgB,GAAZuO,EAAgBtO,OACjEiV,WAAY,kBAAM5C,GAAe,mCAAEtS,EAAF,KAAKC,EAAL,WAAY,CAACD,EAAgB,GAAZuO,EAAgBtO,OAClEkV,QAAS,kBAAM7C,GAAe,yCAAY,CAAZ,UAAgC,GAAZ/D,OAClD6G,UAAW,kBAAM9C,GAAe,yCAAY,CAAZ,UAAgC,GAAZ/D,SACnDhH,SAAQ,mCAAE6L,EAAF,KAAWiC,EAAX,YAAqB7C,EAAY7M,IAAIyN,IAAYiC,OAwD1DC,CACE9C,EACAjE,EACA5K,EACA0O,EACAE,EACAD,GAEF,IAAM1F,EA7DV,SAA6B4F,EAAajE,GACxC,IAAIgH,EAAiB,EASrB,OARAX,OAAOC,QAAQ,CACbW,KAAM,WACJD,GA1LY,KA4LdE,KAAM,WACJF,GA7LY,OA+LbhO,SAAQ,mCAAE6L,EAAF,KAAWiC,EAAX,YAAqB7C,EAAY7M,IAAIyN,IAAYiC,OACrD,IAAIxN,IAAI,CAAC,CAACqJ,GAAKzL,GAAI8P,KAmDCG,CAAoBlD,GACvC7D,EAAcyC,GAAgB1L,EAAUkH,EAAkB2B,GAChEoF,EAAYhF,MAIZ,yBAAKzK,UAAU,aACb,yBAAKA,UAAU,QACb,wBAAIA,UAAU,eAAd,WAOA,yBAAKA,UAAU,cACb,yBAAKA,UAAU,aACZkG,GAAMlE,cAAcR,EAAUkO,Q,qBCrR3ChV,aAAc,OACd+W,MAEApX,OAAOK,GAAKA,EAEZgX,KAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEFC,SAASC,eAAe,SdkHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL5E,QAAQ4E,MAAMA,EAAMC,c","file":"static/js/main.b753dda0.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import * as tf from './tfjs';\n\nexport const ZERO_POS = tf.tensor2d([[0], [0], [1]]);\nexport const ZERO_VEL = tf.tensor2d([[0], [0], [0]]);\nexport const ZERO_STATE = [0, 0];\nexport const DEFAULT_TOLERANCE = 1e-6;\n\nexport class MissingArgumentError extends Error {}\nexport class NotImplementedError extends Error {}\nexport class DimensionError extends Error {}\nexport class SingularMatrixError extends Error {}\n\nexport function required(name) {\n  throw new MissingArgumentError(`Missing required function argument: ${name}`);\n}\n\nexport function coercePositionVector(position = required('position')) {\n  /**\n   * Convert the input argument into a tensor of shape `[3, 1]`, corresponding\n   * to an affine position vector where the final component is guaranteed to\n   * have a value of 1.\n   * @param {(number|number[]|tf.Tensor)} position\n   * @returns {tf.Tensor}\n   */\n  if (position instanceof tf.Tensor) {\n    const data = position.dataSync();\n    if (data.length < 2 || data.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` tensor to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor1d([data[0], data[1], 1]).reshape([3, 1]);\n  } else if (position instanceof Array) {\n    if (position.length < 2 || position.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` array to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor2d([[position[0]], [position[1]], [1]]);\n  } else if (typeof position == 'number') {\n    position = tf.tensor2d([[position], [0], [1]]);\n  } else {\n    throw new TypeError(\n      `Expected \\`position\\` to be a number, array, or tf.Tensor instance; got ${position}`,\n    );\n  }\n  return position;\n}\n\nexport function coerceStateTuple(state = required('state')) {\n  /**\n   * Convert the input into a pair of numbers as a `[position, velocity]`\n   * list/tuple.\n   * @param {(number|number[])} state\n   * @returns {(number[])}\n   */\n  if (state == null) {\n    state = ZERO_STATE;\n  } else if (state === ZERO_STATE) {\n  } else if (typeof state == 'number') {\n    state = [state, 0];\n  } else if (state instanceof Array) {\n    if (state.length === 0 || state.length > 2) {\n      throw new DimensionError(\n        `Expected \\`state\\` tuple/array to have 1 or 2 elements; got ${state}`,\n      );\n    }\n    state = [state[0], state.length > 1 ? state[1] : 0];\n  } else {\n    throw new TypeError(\n      `Expected \\`state\\` to be tf.Tensor instance; got ${state}`,\n    );\n  }\n  return state;\n}\n\nexport function getScaleMatrix(x = required('x'), y = undefined) {\n  if (y == null) {\n    y = x;\n  }\n  return tf.tensor2d([\n    [x, 0, 0],\n    [0, y, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getRotationMatrix(angle = required('angle')) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, 0],\n    [s, c, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getTranslationMatrix(offset = required('offset')) {\n  offset = coercePositionVector(offset).dataSync();\n  return tf.tensor2d([\n    [1, 0, offset[0]],\n    [0, 1, offset[1]],\n    [0, 0, offset[2]],\n  ]);\n}\n\nexport function getRotationTranslationMatrix(\n  angle = required('angle'),\n  offset = required('offset'),\n) {\n  offset = coercePositionVector(offset).dataSync();\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, offset[0]],\n    [s, c, offset[1]],\n    [0, 0, offset[2]],\n  ]);\n}\n\nexport function checkXformMatrixShape(mat = required('mat')) {\n  if (!(mat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected transformation matrix \\`mat\\` to be tf.Tensor instance; got ${mat.toString()}`,\n    );\n  }\n  if (mat.shape.length !== 2 || mat.shape[0] !== 3 || mat.shape[1] !== 3) {\n    throw new DimensionError(\n      `Expected transformation matrix \\`mat\\` to have shape [3, 3]; got ${mat.toString()}`,\n    );\n  }\n}\n\nexport function getXformMatrixDeterminant(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return data[0] * data[4] - data[1] * data[3];\n}\n\nexport function getXformMatrixScaleFactor(mat = required('mat')) {\n  return Math.sqrt(Math.abs(getXformMatrixDeterminant(mat)));\n}\n\nexport function getXformMatrixRotationAngle(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return Math.atan2(data[1], -data[0]);\n}\n\nexport function getXformMatrixTranslation(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return tf.tensor2d([[data[2], data[5], data[8]]]);\n}\n\nexport function invertXformMatrix(mat = required('mat')) {\n  /**\n   * Invert a 3x3 transformation matrix.\n   */\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  const det =\n    data[0] * data[4] * data[8] +\n    data[1] * data[5] * data[6] +\n    data[2] * data[3] * data[7] -\n    data[0] * data[5] * data[7] -\n    data[1] * data[3] * data[8] -\n    data[2] * data[4] * data[6];\n  return tf.tensor2d([\n    [\n      +(data[4] * data[8] - data[5] * data[7]) / det,\n      -(data[1] * data[8] - data[2] * data[7]) / det,\n      +(data[1] * data[5] - data[2] * data[4]) / det,\n    ],\n    [\n      -(data[3] * data[8] - data[5] * data[6]) / det,\n      +(data[0] * data[8] - data[2] * data[6]) / det,\n      -(data[0] * data[5] - data[2] * data[3]) / det,\n    ],\n    [\n      +(data[3] * data[7] - data[4] * data[6]) / det,\n      -(data[0] * data[7] - data[1] * data[6]) / det,\n      +(data[0] * data[4] - data[1] * data[3]) / det,\n    ],\n  ]);\n}\n\nexport function solveLinearSystem(\n  aMat = required('aMat'),\n  bVec = required('bVec'),\n  { asTensor = true } = {},\n) {\n  /**\n   * Solve a linear system of equations using QR decomposition and\n   * back-substitution.\n   */\n  if (!(aMat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`aMat\\` to be tf.Tensor instance; got ${aMat}`,\n    );\n  } else if (!(bVec instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`bVec\\` to be tf.Tensor instance; got ${bVec}`,\n    );\n  } else if (aMat.shape.length !== 2 || aMat.shape[0] !== aMat.shape[1]) {\n    throw new DimensionError(\n      'Expected `aMat` to be a square matrix (2D tensor); ' +\n        `got tensor with shape ${JSON.stringify(aMat.shape)}`,\n    );\n  } else if (bVec.shape.length !== 2 || bVec.shape[1] !== 1) {\n    throw new DimensionError(\n      'Expected `bVec` to be a column vector (2D tensor with one column); ' +\n        `got tensor with shape ${JSON.stringify(bVec.shape)}`,\n    );\n  } else if (aMat.shape[1] !== bVec.shape[0]) {\n    throw new DimensionError(\n      'Expected `aMat` and `bVec` to have compatible shapes; ' +\n        `got aMat shape ${JSON.stringify(aMat.shape)} ` +\n        `and bVec shape ${JSON.stringify(bVec.shape)}`,\n    );\n  }\n  const n = bVec.shape[0];\n  const [qMat, rMat] = tf.linalg.qr(aMat);\n  const cVec = qMat.transpose().matMul(bVec).dataSync();\n  const rArray = rMat.arraySync();\n  const xArray = Array(n);\n  for (let i = n - 1; i >= 0; i--) {\n    if (Math.abs(rArray[i][i]) < DEFAULT_TOLERANCE) {\n      throw new SingularMatrixError(`Singular matrix: ${aMat.toString()}`);\n    }\n    let sum = 0;\n    for (let j = i + 1; j < n; j++) {\n      sum += rArray[i][j] * xArray[j];\n    }\n    xArray[i] = (cVec[i] - sum) / rArray[i][i];\n  }\n  return asTensor ? tf.tensor1d(xArray).reshape([n, 1]) : xArray;\n}\n\nexport function areTensorsEqual(\n  t1 = required('t1'),\n  t2 = required('t2'),\n  { tolerance = DEFAULT_TOLERANCE } = {},\n) {\n  return !!tf.all(t1.sub(t2).abs().less(tolerance)).dataSync()[0];\n}\n\nexport function generateRandomId() {\n  /** See `https://gist.github.com/gordonbrander/2230317`.\n   */\n  return Math.random().toString(36).substr(2, 9);\n}\n","import { NotImplementedError } from './utils';\nimport { required } from './utils';\n\nexport default class Decal {\n  xform(xformMatrix = required('xformMatrix')) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    throw new NotImplementedError('abstract method');\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getRotationTranslationMatrix } from './utils';\nimport { getScaleMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nconst CENTERED_SQUARE = tf\n  .tensor2d([\n    [-0.5, -0.5, 1],\n    [0.5, -0.5, 1],\n    [0.5, 0.5, 1],\n    [-0.5, 0.5, 1],\n  ])\n  .transpose();\n\nconst QUAD1_SQUARE = tf\n  .tensor2d([\n    [0, 0, 1],\n    [1, 0, 1],\n    [1, 1, 1],\n    [0, 1, 1],\n  ])\n  .transpose();\n\nexport default class BoxDecal extends Decal {\n  constructor({\n    width = 1,\n    height = 1,\n    position = ZERO_POS,\n    angle = 0,\n    centered = true,\n    solid = true,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.width = width;\n    this.height = height;\n    this.position = coercePositionVector(position);\n    this.angle = angle;\n    this.centered = !!centered;\n    this.solid = !!solid;\n    this.lineWidth = lineWidth;\n    this.color = color;\n    this._cornerPositions = getRotationTranslationMatrix(-angle, this.position)\n      .matMul(getScaleMatrix(width, height))\n      .matMul(centered ? CENTERED_SQUARE : QUAD1_SQUARE);\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return new BoxDecal({\n      width: this.width * scale,\n      height: this.height * scale,\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      centered: this.centered,\n      solid: this.solid,\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    let element;\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    const cornerPositions = xformMatrix.matMul(this._cornerPositions).arraySync();\n    if (this.solid) {\n      element = (\n        <rect\n          x={cornerPositions[0][3]}\n          y={cornerPositions[1][3]}\n          width={this.width * scale}\n          height={this.height * scale}\n          key={key}\n        />\n      );\n    } else {\n      const npoints = this._cornerPositions.shape[1];\n      const lines = [];\n      for (let i = 0; i < npoints; i++) {\n        const j = (i + 1) % npoints;\n        lines.push(\n          <line\n            className=\"plot__line\"\n            x1={cornerPositions[0][i]}\n            y1={cornerPositions[1][i]}\n            x2={cornerPositions[0][j]}\n            y2={cornerPositions[1][j]}\n            strokeWidth={this.lineWidth * scale}\n            stroke={this.color}\n            key={i}\n          />,\n        );\n      }\n      element = <g key={key}>{lines}</g>;\n    }\n    return element;\n  }\n}\n","import Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class CircleDecal extends Decal {\n  constructor({ position = ZERO_POS, radius = 1, color = 'black' } = {}) {\n    super();\n    this.position = coercePositionVector(position);\n    this.radius = radius;\n    this.color = color;\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return CircleDecal({\n      position: xformMatrix.matMul(this.position),\n      radius: this.radius * scale,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const xformed = xformMatrix.matMul(this.position).dataSync();\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <circle\n        className=\"plot__circle\"\n        cx={xformed[0]}\n        cy={xformed[1]}\n        r={this.radius * scale}\n        fill={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class LineDecal extends Decal {\n  constructor({\n    endPos = required('endPos'),\n    startPos = ZERO_POS,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.startPos = coercePositionVector(startPos);\n    this.endPos = coercePositionVector(endPos);\n    this.lineWidth = lineWidth;\n    this.color = color;\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return LineDecal({\n      endPos: xformMatrix.matMul(this.endPos),\n      startPos: xformMatrix.matMul(this.startPos),\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const startPos = xformMatrix.matMul(this.startPos).dataSync();\n    const endPos = xformMatrix.matMul(this.endPos).dataSync();\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <line\n        className=\"plot__line\"\n        x1={startPos[0]}\n        y1={startPos[1]}\n        x2={endPos[0]}\n        y2={endPos[1]}\n        strokeWidth={this.lineWidth * scale}\n        stroke={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { coerceStateTuple } from './utils';\nimport { generateRandomId } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n  } = {}) {\n    this.id = id != null ? id : generateRandomId();\n    this.position = coercePositionVector(position);\n    this.decals = decals;\n    this.weights = weights;\n    this.frames = frames;\n    this.resistance = resistance;\n    this.initialState = coerceStateTuple(initialState);\n  }\n\n  getPosMatrix(q = required('q')) {\n    return tf.eye(3);\n  }\n\n  getVelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getAccelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const [q] = stateMap.has(this.id) ? stateMap.get(this.id) : ZERO_STATE;\n    xformMatrix = xformMatrix.matMul(this.getPosMatrix(q));\n    return (\n      <g className=\"frame\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, { key: 'frame' + index }),\n        )}\n      </g>\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class RotationalFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n  } = {}) {\n    super({\n      position: position,\n      decals: decals,\n      weights: weights,\n      frames: frames,\n      resistance: resistance,\n      initialState: initialState,\n      id: id,\n    });\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new RotationalFrame({\n      position: xformMatrix.matMul(this.position),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [c, -s, position[0]],\n      [s, c, position[1]],\n      [0, 0, 1],\n    ]);\n  }\n\n  getVelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-s, -c, 0],\n      [c, -s, 0],\n      [0, 0, 0],\n    ]);\n  }\n\n  getAccelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-c, s, 0],\n      [-s, -c, 0],\n      [0, 0, 0],\n    ]);\n  }\n}\n","export const defaultGetNodeParents = (x) => x.parents;\nexport const defaultGetNodeKey = (x) => x;\n\nexport function toposort(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {},\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const markedNodes = new Set();\n  const sortedNodes = [];\n  const sortedKeys = [];\n  const unvisitedNodes = [...nodes];\n\n  function visit(node, child) {\n    const nodeKey = getNodeKey(node);\n    if (markedNodes.has(nodeKey)) {\n      throw new Error(`Graph is not a DAG; recursively encountered ${node}`);\n    }\n    if (!sortedKeys.includes(nodeKey)) {\n      const parents = getNodeParents(node);\n      if (parents) {\n        markedNodes.add(nodeKey);\n        parents.forEach((parent) => visit(parent, node));\n        markedNodes.delete(nodeKey);\n        sortedNodes.push(node);\n        sortedKeys.push(nodeKey);\n      }\n    }\n  }\n\n  while (unvisitedNodes.length) {\n    const node = unvisitedNodes.pop();\n    visit(node, null);\n  }\n  return sortedNodes;\n}\n\nexport function getChildMap(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {},\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const childMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parents = getNodeParents(node);\n    childMap.has(nodeKey) || childMap.set(nodeKey, new Set());\n    parents.forEach((parent) => {\n      const parentKey = getNodeKey(parent);\n      childMap.has(parentKey) || childMap.set(parentKey, new Set());\n      childMap.get(parentKey).add(node);\n    });\n  });\n  return childMap;\n}\n\nexport function transform(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n    visitEdge = undefined,\n  } = {},\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  visitNode = visitNode || ((node, parentValues) => null);\n  visitEdge = visitEdge || ((node, parentNode, parentValue) => parentValue);\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const nodeMap = new Map();\n  const edgeMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parentNodes = getNodeParents(node);\n    const parentEdgeValues = parentNodes.map((parentNode) => {\n      const parentNodeKey = getNodeKey(parentNode);\n      const edgeValue = visitEdge(node, parentNode, nodeMap.get(parentNodeKey));\n      edgeMap.set([parentNodeKey, nodeKey], edgeValue);\n      return edgeValue;\n    });\n    const nodeValue = visitNode(node, parentEdgeValues);\n    nodeMap.set(nodeKey, nodeValue);\n  });\n  return [nodeMap, edgeMap];\n}\n\nexport function transformNodes(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n  } = {},\n) {\n  const [nodeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitNode: visitNode,\n  });\n  return nodeMap;\n}\n\nexport function transformEdges(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitEdge = undefined,\n  } = {},\n) {\n  const [, edgeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitEdge: visitEdge,\n  });\n  return edgeMap;\n}\n","import * as daglet from './daglet';\nimport * as tf from './tfjs';\nimport React from 'react';\nimport { required } from './utils';\n\nexport const DEFAULT_GRAVITY = 10;\n\nexport default class Scene {\n  constructor({\n    decals = [],\n    frames = [],\n    springs = [],\n    constraints = [],\n    gravity = DEFAULT_GRAVITY,\n  } = {}) {\n    this.decals = decals;\n    this.frames = frames;\n    this.springs = springs;\n    this.constraints = constraints;\n    this.gravity = gravity;\n\n    const getFrameChildren = (frame) => frame.frames;\n    const getFrameId = (frame) => frame.id;\n    this.sortedFrames = daglet\n      .toposort(this.frames, {\n        getNodeParents: getFrameChildren,\n        getNodeKey: getFrameId,\n      })\n      .reverse();\n    this.frameMap = new Map(\n      this.sortedFrames.map((frame) => [frame.id, frame]),\n    );\n    const frameIdParentsMap = daglet.getChildMap(this.sortedFrames, {\n      getNodeParents: getFrameChildren,\n      getNodeKey: getFrameId,\n    });\n    if ([...frameIdParentsMap.values()].some((parents) => parents.size > 1)) {\n      throw new Error('Frames should only have one parent'); // TODO: use AssertionError?\n    }\n    this.frameIdParentMap = new Map(\n      [...frameIdParentsMap].map(([frameId, parents]) => [\n        frameId,\n        parents.size ? [...parents][0].id : null,\n      ]),\n    );\n    this.frameIdPathMap = daglet.transformNodes(this.sortedFrames, {\n      getNodeParents: (frame) => [...frameIdParentsMap.get(frame.id)],\n      getNodeKey: getFrameId,\n      visitNode: (frame, parentPaths) =>\n        parentPaths.length ? [...parentPaths[0], frame.id] : [frame.id],\n    });\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = tf.eye(3),\n    { key = undefined } = {},\n  ) {\n    return (\n      <g className=\"scene\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, { key: 'frame' + index }),\n        )}\n      </g>\n    );\n  }\n\n  getInitialStateMap({ randomize = false } = {}) {\n    let getInitialState;\n    if (randomize) {\n      const randPi = () => (Math.random() - 0.5) * Math.PI * 2; // TBD\n      getInitialState = (frame) => [randPi(), randPi()];\n    } else {\n      getInitialState = (frame) => frame.initialState;\n    }\n    return new Map(\n      this.sortedFrames.map((frame) => [frame.id, getInitialState(frame)]),\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport { invertXformMatrix } from './utils';\nimport { required } from './utils';\nimport { solveLinearSystem } from './utils';\n\nexport default class Solver {\n  constructor(scene = required('scene')) {\n    this.scene = scene;\n  }\n\n  _getPosMatMap(stateMap = required('stateMap')) {\n    /**\n     * Determine all the local->global position transformation matrices,\n     * indexed by frame.\n     */\n    const posMatMap = new Map();\n    for (let frame of this.scene.sortedFrames) {\n      const [q] = stateMap.get(frame.id);\n      const parentId = this.scene.frameIdParentMap.get(frame.id);\n      let mat = frame.getPosMatrix(q);\n      if (parentId) {\n        mat = posMatMap.get(parentId).matMul(mat);\n      }\n      posMatMap.set(frame.id, mat);\n    }\n    return posMatMap;\n  }\n\n  _getInvPosMatMap(posMatMap = required('posMatMap')) {\n    /**\n     * Determine all the global->local (\"inverse\") position transformation\n     * matrices, indexed by frame.\n     */\n    return new Map(\n      [...posMatMap].map(([frameId, posMat]) => [\n        frameId,\n        invertXformMatrix(posMat),\n      ]),\n    );\n  }\n\n  _getVelMatMap(\n    posMatMap = required('posMatMap'),\n    invPosMatMap = required('invPosMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    /**\n     * Determine all the global position -> global velocity transformation\n     * matrices, indexed by frame, where each matrix represents the velocity\n     * field of the corresponding frame in global coordinates, such that\n     * right-multiplying the matrix by a global position vector yields a global\n     * velocity vector.\n     */\n    return new Map(\n      this.scene.sortedFrames.map((frame) => {\n        const [q] = stateMap.get(frame.id);\n        const parentId = this.scene.frameIdParentMap.get(frame.id);\n        let mat = frame.getVelMatrix(q).matMul(invPosMatMap.get(frame.id));\n        if (parentId) {\n          mat = posMatMap.get(parentId).matMul(mat);\n        }\n        return [frame.id, mat];\n      }),\n    );\n  }\n\n  _getAccelMatMap(\n    posMatMap = required('posMatMap'),\n    invPosMatMap = required('invPosMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    /**\n     * Global position -> global acceleration, indexed by frame, where each\n     * matrix represents the acceleration field of the corresponding frame in\n     * global coordinates.\n     */\n    return new Map(\n      this.scene.sortedFrames.map((frame) => {\n        const [q] = stateMap.get(frame.id);\n        const parentId = this.scene.frameIdParentMap.get(frame.id);\n        let mat = frame.getAccelMatrix(q).matMul(invPosMatMap.get(frame.id));\n        if (parentId) {\n          mat = posMatMap.get(parentId).matMul(mat);\n        }\n        return [frame.id, mat];\n      }),\n    );\n  }\n\n  _getVelSumMatMap(\n    posMatMap = required('posMatMap'),\n    velMatMap = required('velMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    const velSumMatMap = new Map();\n    for (let frame of this.scene.sortedFrames) {\n      const [, qd] = stateMap.get(frame.id);\n      const parentId = this.scene.frameIdParentMap.get(frame.id);\n      let mat = velMatMap.get(frame.id).mul(qd);\n      if (parentId) {\n        mat = mat.add(velSumMatMap.get(parentId));\n      }\n      velSumMatMap.set(frame.id, mat);\n    }\n    return velSumMatMap;\n  }\n\n  _getAccelSumMatMap(\n    posMatMap = required('posMatMap'),\n    velMatMap = required('velMatMap'),\n    accelMatMap = required('accelMatMap'),\n    velSumMatMap = required('velSumMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    const accelSumMatMap = new Map();\n    for (let frame of this.scene.sortedFrames) {\n      const [, qd] = stateMap.get(frame.id);\n      const parentId = this.scene.frameIdParentMap.get(frame.id);\n      let mat = accelMatMap.get(frame.id).mul(qd * qd);\n      if (parentId) {\n        const parentAccelSumMat = accelSumMatMap.get(parentId);\n        const parentVelSumMat = velSumMatMap.get(parentId);\n        const velMat = velMatMap.get(frame.id);\n        mat = mat\n          .add(parentAccelSumMat)\n          .add(parentVelSumMat.matMul(velMat).mul(2 * qd));\n      }\n      accelSumMatMap.set(frame.id, mat);\n    }\n    return accelSumMatMap;\n  }\n\n  _getWeightPosMap(posMatMap = required('posMatMap')) {\n    /**\n     * Transform all the weight positions of all the frames into global\n     * positions, indexed by frame and mass reference.\n     */\n    return new Map(\n      this.scene.sortedFrames.map((frame) => [\n        frame.id,\n        frame.weights.map((weight) =>\n          posMatMap.get(frame.id).matMul(weight.position),\n        ),\n      ]),\n    );\n  }\n\n  _isFrameDescendent(\n    descendentFrame = required('descendentFrame'),\n    ancestorFrame = required('ancestorFrame'),\n  ) {\n    return (\n      this.scene.frameIdPathMap\n        .get(descendentFrame.id)\n        .indexOf(ancestorFrame.id) !== -1\n    );\n  }\n\n  _getDescendentFrame(\n    frame1 = required('frame1'),\n    frame2 = required('frame2'),\n  ) {\n    let descendent;\n    if (this._isFrameDescendent(frame1, frame2)) {\n      descendent = frame1;\n    } else if (this._isFrameDescendent(frame2, frame1)) {\n      descendent = frame2;\n    } else {\n      descendent = null;\n    }\n    return descendent;\n  }\n\n  _getDescendentFrames(ancestorFrame = required('ancestorFrame')) {\n    return this.scene.sortedFrames.filter((frame) =>\n      this._isFrameDescendent(frame, ancestorFrame),\n    );\n  }\n\n  _getCoefficientMatrixEntry(\n    rowIndex = required('rowIndex'),\n    colIndex = required('colIndex'),\n    velMatMap = required('velMatMap'),\n    weightPosMap = required('weightPosMap'),\n  ) {\n    const frame1 = this.scene.sortedFrames[rowIndex];\n    const frame2 = this.scene.sortedFrames[colIndex];\n    const velMat1 = velMatMap.get(frame1.id);\n    const velMat2 = velMatMap.get(frame2.id);\n    const baseFrame = this._getDescendentFrame(frame1, frame2);\n    const descendentFrames = baseFrame\n      ? this._getDescendentFrames(baseFrame)\n      : [];\n    let result = 0;\n    for (let frame3 of descendentFrames) {\n      for (let index = 0; index < frame3.weights.length; index++) {\n        const weight = frame3.weights[index];\n        const pos = weightPosMap.get(frame3.id)[index];\n        result +=\n          weight.mass *\n          tf\n            .matMul(velMat2.matMul(pos), velMat1.matMul(pos), true)\n            .dataSync()[0];\n      }\n    }\n    return result;\n  }\n\n  _getCoefficientMatrix(\n    velMatMap = required('velMatMap'),\n    weightPosMap = required('weightPosMap'),\n  ) {\n    const numFrames = this.scene.sortedFrames.length;\n    const array = Array(numFrames);\n    for (let rowIndex = 0; rowIndex < numFrames; rowIndex++) {\n      const columns = Array(numFrames);\n      for (let colIndex = 0; colIndex < numFrames; colIndex++) {\n        columns[colIndex] = this._getCoefficientMatrixEntry(\n          rowIndex,\n          colIndex,\n          velMatMap,\n          weightPosMap,\n        );\n      }\n      array[rowIndex] = columns;\n    }\n    return tf.tensor2d(array);\n  }\n\n  _getForceVectorEntry(\n    baseFrame = required('baseFrame'),\n    velMatMap = required('velMatMap'),\n    velSumMatMap = required('velSumMatMap'),\n    accelSumMatMap = required('accelSumMatMap'),\n    weightPosMap = required('weightPosMap'),\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    let result = 0;\n    const baseVelMat = velMatMap.get(baseFrame.id);\n    for (let childFrame of this._getDescendentFrames(baseFrame)) {\n      const childVelSumMat = velSumMatMap.get(childFrame.id);\n      const childAccelSumMat = accelSumMatMap.get(childFrame.id);\n      for (\n        let weightIndex = 0;\n        weightIndex < childFrame.weights.length;\n        weightIndex++\n      ) {\n        const weight = childFrame.weights[weightIndex];\n        const weightPos = weightPosMap.get(childFrame.id)[weightIndex];\n        const weightBaseVel = baseVelMat.matMul(weightPos);\n        const weightChildVelSum = childVelSumMat.matMul(weightPos);\n        const weightChildAccelSum = childAccelSumMat.matMul(weightPos);\n        const kineticForce =\n          -weight.mass *\n          weightBaseVel.matMul(weightChildAccelSum, true).dataSync()[0];\n        const gravityForce =\n          -weight.mass * this.scene.gravity * weightBaseVel.dataSync()[1];\n        const dragForce =\n          -weight.drag *\n          weightBaseVel.matMul(weightChildVelSum, true).dataSync()[0];\n        result = kineticForce + dragForce + gravityForce;\n      }\n      const [, qd] = stateMap.get(baseFrame.id);\n      const resistanceForce = -baseFrame.resistance * qd;\n      const externalForce =\n        (externalForceMap && externalForceMap.get(baseFrame.id)) || 0;\n      result += externalForce + resistanceForce;\n    }\n    return result;\n  }\n\n  _getForceVector(\n    velMatMap = required('velMatMap'),\n    velSumMatMap = required('velSumMatMap'),\n    accelSumMatMap = required('accelSumMatMap'),\n    weightPosMap = required('weightPosMap'),\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const numFrames = this.scene.sortedFrames.length;\n    const array = Array(numFrames);\n    for (let index = 0; index < numFrames; index++) {\n      array[index] = this._getForceVectorEntry(\n        this.scene.sortedFrames[index],\n        velMatMap,\n        velSumMatMap,\n        accelSumMatMap,\n        weightPosMap,\n        stateMap,\n        externalForceMap,\n      );\n    }\n    return tf.tensor1d(array).reshape([numFrames, 1]);\n  }\n\n  _getSystemOfEquations(\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const posMatMap = this._getPosMatMap(stateMap);\n    const invPosMatMap = this._getInvPosMatMap(posMatMap);\n    const velMatMap = this._getVelMatMap(posMatMap, invPosMatMap, stateMap);\n    const accelMatMap = this._getAccelMatMap(posMatMap, invPosMatMap, stateMap);\n    const velSumMatMap = this._getVelSumMatMap(posMatMap, velMatMap, stateMap);\n    const accelSumMatMap = this._getAccelSumMatMap(\n      posMatMap,\n      velMatMap,\n      accelMatMap,\n      velSumMatMap,\n      stateMap,\n    );\n    const weightPosMap = this._getWeightPosMap(posMatMap);\n    const aMat = this._getCoefficientMatrix(velMatMap, weightPosMap);\n    const bVec = this._getForceVector(\n      velMatMap,\n      velSumMatMap,\n      accelSumMatMap,\n      weightPosMap,\n      stateMap,\n      externalForceMap,\n    );\n    return [aMat, bVec];\n  }\n\n  _solve(\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const [aMat, bVec] = this._getSystemOfEquations(stateMap, externalForceMap);\n    return solveLinearSystem(aMat, bVec, { asTensor: false });\n  }\n\n  _applyDeltas(\n    stateMap = required('stateMap'),\n    deltaTime = required('deltaTime'),\n    qddArray = required('qddArray'),\n    qdArray = undefined,\n    { inPlace = false } = {},\n  ) {\n    const newStateMap = inPlace ? stateMap : new Map();\n    if (qdArray == null) {\n      qdArray = [...stateMap].map(([frame, [q, qd]]) => qd);\n    }\n    for (let index = 0; index < this.scene.sortedFrames.length; index++) {\n      const frame = this.scene.sortedFrames[index];\n      const [q] = stateMap.get(frame.id);\n      const qd = qdArray[index];\n      const qdd = qddArray[index];\n      const newQ = q + qd * deltaTime;\n      const newQd = qd + qdd * deltaTime;\n      newStateMap.set(frame.id, [newQ, newQd]);\n    }\n    return newStateMap;\n  }\n\n  _tickSimple(\n    stateMap = required('stateMap'),\n    deltaTime = required('deltaTime'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const qddArray = this._solve(stateMap, externalForceMap);\n    return this._applyDeltas(stateMap, deltaTime, qddArray);\n  }\n\n  _makeStateMap(qs = required('qs'), qds = required('qds')) {\n    return new Map(\n      this.scene.sortedFrames.map((frame, index) => [\n        frame.id,\n        [qs[index], qds[index]],\n      ]),\n    );\n  }\n\n  _tickRungeKutta(\n    stateMap = required('stateMap'),\n    deltaTime = required('deltaTime'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const solve = (stateMap) => this._solve(stateMap, externalForceMap);\n\n    const sm0 = stateMap;\n    const qds0 = [...sm0].map(([frame, [q, qd]]) => qd);\n    const qdds0 = solve(sm0);\n\n    const sm1 = this._applyDeltas(sm0, deltaTime / 2, qdds0, qds0);\n    const qds1 = [...sm1].map(([frame, [q, qd]]) => qd);\n    const qdds1 = solve(sm1);\n\n    const sm2 = this._applyDeltas(sm0, deltaTime / 2, qdds1, qds1);\n    const qds2 = [...sm2].map(([frame, [q, qd]]) => qd);\n    const qdds2 = solve(sm2);\n\n    const sm3 = this._applyDeltas(sm0, deltaTime / 2, qdds2, qds2);\n    const qds3 = [...sm3].map(([frame, [q, qd]]) => qd);\n    const qdds3 = solve(sm3);\n\n    const sm4 = this._applyDeltas(sm0, deltaTime, qdds3, qds3);\n    const qds4 = [...sm4].map(([frame, [q, qd]]) => qd);\n    const qdds4 = solve(sm4);\n\n    let sm = sm0;\n    sm = this._applyDeltas(sm, deltaTime / 6, qdds1, qds1);\n    sm = this._applyDeltas(sm, deltaTime / 3, qdds2, qds2 /*{inPlace: true}*/);\n    sm = this._applyDeltas(sm, deltaTime / 3, qdds3, qds3 /*{inPlace: true}*/);\n    sm = this._applyDeltas(sm, deltaTime / 6, qdds4, qds4 /*{inPlace: true}*/);\n    return sm;\n  }\n\n  tick(\n    stateMap = required('stateMap'),\n    deltaTime = required('deltaTime'),\n    externalForceMap = null,\n    { rungeKutta = false } = {},\n  ) {\n    const doTick = rungeKutta ? this._tickRungeKutta : this._tickSimple;\n    return doTick.bind(this)(stateMap, deltaTime, externalForceMap);\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { getTranslationMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class TrackFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    angle = 0,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = undefined,\n  } = {}) {\n    super({\n      angle: angle,\n      decals: decals,\n      weights: weights,\n      frames: frames,\n      resistance: resistance,\n      initialState: initialState,\n      position: position,\n      id: id,\n    });\n    this.angle = angle;\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new TrackFrame({\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    return getTranslationMatrix([\n      position[0] + q * Math.cos(this.angle),\n      position[1] + q * Math.sin(this.angle),\n    ]);\n  }\n\n  getVelMatrix(q = required('q')) {\n    return tf.tensor2d([\n      [0, 0, Math.cos(this.angle)],\n      [0, 0, Math.sin(this.angle)],\n      [0, 0, 0],\n    ]);\n  }\n}\n","import { coercePositionVector } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class Weight {\n  constructor(mass = 1, { position = ZERO_POS, drag = 0 } = {}) {\n    this.mass = mass;\n    this.position = coercePositionVector(position);\n    this.drag = drag;\n  }\n\n  xform(xformMatrix) {\n    return new Weight({\n      mass: this.mass,\n      position: xformMatrix.matMul(this.position),\n      drag: this.drag,\n    });\n  }\n}\n","import './App.css';\nimport 'normalize.css';\nimport BoxDecal from './BoxDecal';\nimport CircleDecal from './CircleDecal';\nimport LineDecal from './LineDecal';\nimport producer from 'immer';\nimport React from 'react';\nimport RotationalFrame from './RotationalFrame';\nimport Scene from './Scene';\nimport Solver from './Solver';\nimport TrackFrame from './TrackFrame';\nimport Weight from './Weight';\nimport { getScaleMatrix } from './utils';\nimport { getTranslationMatrix } from './utils';\nimport { useEffect } from 'react';\nimport { useRef } from 'react';\nimport { useState } from 'react';\n\nconst poiMass = 40;\nconst poiDrag = 12;\nconst ropeSegmentLength = 6;\nconst ropeSegmentDrag = 5;\nconst ropeSegmentMass = 1;\nconst ropeSegmentResistance = 30;\nconst ropeSegmentCount = 2;\nconst cartForce = 5000;\nconst cartResistance = 5;\nconst rungeKutta = false;\n\nconst MIN_ANIMATION_FPS = 1;\nconst TARGET_ANIMATION_FPS = 30;\nconst TARGET_PHYSICS_FPS = 100;\n\nconst poi = new RotationalFrame({\n  id: 'poi',\n  initialState: [0, 0],\n  decals: [\n    new LineDecal({ endPos: [ropeSegmentLength, 0], lineWidth: 0.2 }),\n    new CircleDecal({\n      position: [ropeSegmentLength, 0],\n      radius: 1,\n    }),\n  ],\n  position: [ropeSegmentLength, 0],\n  weights: [\n    new Weight(poiMass, { position: [ropeSegmentLength, 0], drag: poiDrag }),\n  ],\n  resistance: ropeSegmentResistance,\n});\n\nconst isLastRopeSegment = (segmentIndex) =>\n  segmentIndex === ropeSegmentCount - 2;\n\nconst segments = Array(ropeSegmentCount - 1)\n  .fill()\n  .map((x, index) => index)\n  .reduce(\n    (childFrames, index) => [\n      new RotationalFrame({\n        id: `segment${index}`,\n        initialState: isLastRopeSegment(index) ? [Math.PI * -0.3, 0] : [0, 0],\n        decals: [\n          new LineDecal({ endPos: [ropeSegmentLength, 0], lineWidth: 0.2 }),\n          new CircleDecal({\n            position: [ropeSegmentLength, 0],\n            radius: 0.4,\n          }),\n        ],\n        frames: childFrames,\n        position: isLastRopeSegment(index) ? [0, 0] : [ropeSegmentLength, 0],\n        weights: [\n          new Weight(ropeSegmentMass, {\n            position: [ropeSegmentLength, 0],\n            drag: ropeSegmentDrag,\n          }),\n        ],\n        resistance: ropeSegmentResistance,\n      }),\n    ],\n    [poi],\n  );\n\nconst cart = new TrackFrame({\n  id: 'cart',\n  decals: [\n    new BoxDecal({\n      width: 3,\n      height: 3 / 1.618,\n      //color: 'blue',\n      lineWidth: 0.2,\n    }),\n  ],\n  frames: segments,\n  weights: [new Weight(150)],\n  resistance: cartResistance,\n});\n\nconst scene = new Scene({\n  frames: [cart],\n  decals: [\n    new LineDecal({\n      startPos: [-300, 0],\n      endPos: [300, 0],\n      color: 'gray',\n      lineWidth: 0.1,\n    }),\n  ],\n});\nconst solver = new Solver(scene);\n\nfunction useKeyboard(callback) {\n  const [pressedKeys, setPressedKeys] = useState(new Set());\n  const callbackRef = useRef();\n  callbackRef.current = callback;\n\n  useEffect(() => {\n    function handleKeyDown({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (!pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.add(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: true,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n    function handleKeyUp({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.delete(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: false,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n\n  return pressedKeys;\n}\n\nconst useAnimationFrame = (callback, { fps = TARGET_ANIMATION_FPS } = {}) => {\n  const state = React.useRef({ prevTime: 0 });\n  const requestRef = React.useRef();\n  const timerRef = React.useRef();\n  state.current.callback = callback;\n\n  React.useEffect(() => {\n    function animate(time) {\n      const deltaTime = (time - state.current.prevTime) / 1000;\n      const delay = Math.max(1000 / fps - deltaTime, 0);\n      state.current.callback(deltaTime);\n      state.current.prevTime = time;\n      timerRef.current = setTimeout(() => {\n        requestRef.current = requestAnimationFrame(animate);\n      }, delay);\n    }\n\n    requestRef.current = requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n      timerRef.current && clearTimeout(timerRef.current);\n    };\n  }, [fps]);\n};\n\nfunction isValidStateMap(stateMap) {\n  return [...stateMap].every(([frameId, [q, qd]]) => !isNaN(q) && !isNaN(qd));\n}\n\nfunction handleViewControls(\n  pressedKeys,\n  deltaTime,\n  scale,\n  translation,\n  setScale,\n  setTranslation,\n) {\n  Object.entries({\n    Minus: () => setScale(scale * Math.exp(-deltaTime)),\n    Equal: () => setScale(scale * Math.exp(deltaTime)),\n    ArrowLeft: () => setTranslation(([x, y]) => [x + deltaTime * 20, y]),\n    ArrowRight: () => setTranslation(([x, y]) => [x - deltaTime * 20, y]),\n    ArrowUp: () => setTranslation(([x, y]) => [x, y - deltaTime * 20]),\n    ArrowDown: () => setTranslation(([x, y]) => [x, y + deltaTime * 20]),\n  }).forEach(([keyName, func]) => pressedKeys.has(keyName) && func());\n}\n\nfunction getExternalForceMap(pressedKeys, deltaTime) {\n  let cartForceValue = 0;\n  Object.entries({\n    KeyA: () => {\n      cartForceValue -= cartForce;\n    },\n    KeyD: () => {\n      cartForceValue += cartForce;\n    },\n  }).forEach(([keyName, func]) => pressedKeys.has(keyName) && func());\n  return new Map([[cart.id, cartForceValue]]);\n}\n\nfunction simulatePhysics(stateMap, externalForceMap, animationDeltaTime) {\n  const startTime = new Date().getTime();\n  const deadline = startTime + 1000 / MIN_ANIMATION_FPS;\n  const tickCount = Math.ceil(TARGET_PHYSICS_FPS * animationDeltaTime);\n  const deltaTime = animationDeltaTime / tickCount;\n  for (let timeIndex = 0; timeIndex < tickCount; timeIndex++) {\n    if (new Date().getTime() > deadline) {\n      console.warn(\n        'Deadline exceeded for physics computation; ' +\n          `skipping ${tickCount - timeIndex} ticks`,\n      );\n      break;\n    }\n    stateMap = solver.tick(stateMap, deltaTime, externalForceMap, {\n      rungeKutta: rungeKutta,\n    });\n  }\n  if (!isValidStateMap(stateMap)) {\n    console.warn(\n      'Encountered invalid state map; resetting to initial state...',\n    );\n    stateMap = scene.getInitialStateMap();\n  }\n  return stateMap;\n}\n\nfunction getViewXformMatrix(translation, scale) {\n  return getTranslationMatrix([300, 300])\n    .matMul(getScaleMatrix(scale, -scale))\n    .matMul(getTranslationMatrix(translation));\n}\n\nfunction App() {\n  const [translation, setTranslation] = useState([0, 0]);\n  const [scale, setScale] = useState(10);\n  const pressedKeys = useKeyboard();\n  const [stateMap, setStateMap] = useState(scene.getInitialStateMap());\n  const viewXformMatrix = getViewXformMatrix(translation, scale);\n\n  useAnimationFrame((deltaTime) => {\n    handleViewControls(\n      pressedKeys,\n      deltaTime,\n      scale,\n      translation,\n      setScale,\n      setTranslation,\n    );\n    const externalForceMap = getExternalForceMap(pressedKeys, deltaTime);\n    const newStateMap = simulatePhysics(stateMap, externalForceMap, deltaTime);\n    setStateMap(newStateMap);\n  });\n\n  return (\n    <div className=\"app__main\">\n      <div className=\"plot\">\n        <h2 className=\"plot__title\">CartPoi</h2>\n        {\n          //<p>Keys: {[...pressedKeys].join(', ')}</p>\n        }\n        {\n          //<p>Scale: {scale.toFixed(2)}</p>\n        }\n        <div className=\"plot__main\">\n          <svg className=\"plot__svg\">\n            {scene.getDomElement(stateMap, viewXformMatrix)}\n          </svg>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import './index.css';\nimport * as immer from 'immer';\nimport * as serviceWorker from './serviceWorker';\nimport * as tf from '@tensorflow/tfjs';\nimport App from './App';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\ntf.setBackend('cpu');\nimmer.enableMapSet();\n\nwindow.tf = tf; // (for debugging)\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}