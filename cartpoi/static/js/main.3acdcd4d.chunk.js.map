{"version":3,"sources":["serviceWorker.js","utils.js","Decal.js","BoxDecal.js","CircleDecal.js","Solver.js","LineDecal.js","Frame.js","RotationalFrame.js","RsSolver.js","daglet.js","Scene.js","TrackFrame.js","Weight.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","ZERO_POS","tf","ZERO_STATE","MissingArgumentError","Error","NotImplementedError","DimensionError","required","name","coercePositionVector","position","data","dataSync","length","Array","TypeError","coerceStateTuple","state","getScaleMatrix","x","y","undefined","getTranslationMatrix","offset","offsetData","dispose","getRotationTranslationMatrix","angle","c","Math","cos","s","sin","checkXformMatrixShape","mat","toString","shape","getXformMatrixDeterminant","getXformMatrixScaleFactor","sqrt","abs","getXformMatrixRotationAngle","atan2","generateRandomId","random","substr","Decal","key","CENTERED_SQUARE","transpose","QUAD1_SQUARE","BoxDecal","width","height","centered","solid","lineWidth","color","_cornerPositions","matMul","this","xformMatrix","scale","element","cornerPositions","arraySync","npoints","lines","i","j","push","className","x1","y1","x2","y2","strokeWidth","stroke","CircleDecal","radius","xformed","cx","cy","r","fill","InvalidStateMapError","message","Solver","scene","setStateMap","getInitialStateMap","LineDecal","endPos","startPos","Frame","decals","weights","frames","resistance","initialState","id","typeName","constructor","forEach","frame","weight","stateMap","has","get","q","getLocalPosMatrix","domElement","map","decal","index","getDomElement","includeDecals","obj","toJsonObj","slice","type","RotationalFrame","RsSolver","rsWasmModule","rungeKutta","stateBuffer","Float64Array","sortedFrames","extForceBuffer","resetStateMap","console","log","sceneJson","JSON","stringify","context","SolverContext","setRungeKutta","Map","set","flatMap","deltaTime","tickCount","externalForceMap","tick","isNaN","defaultGetNodeParents","parents","defaultGetNodeKey","toposort","nodes","getNodeParents","getNodeKey","markedNodes","Set","sortedNodes","sortedKeys","visit","node","child","nodeKey","includes","add","parent","delete","getChildMap","childMap","parentKey","transform","visitNode","visitEdge","parentValues","parentNode","parentValue","nodeMap","edgeMap","parentEdgeValues","parentNodeKey","edgeValue","nodeValue","transformNodes","Scene","springs","constraints","gravity","getFrameChildren","getFrameId","daglet","reverse","frameMap","frameIdParentsMap","values","some","size","frameIdParentMap","frameId","frameIdPathMap","parentPaths","getInitialState","randomize","randPi","PI","TrackFrame","options","Weight","mass","drag","segments","reduce","childFrames","first","last","ropeSegmentCount","ropeSegmentLength","cart","App","useState","paused","setPaused","translation","setTranslation","setScale","pressedKeys","callback","setPressedKeys","callbackRef","useRef","current","useEffect","handleKeyDown","code","keyCode","producer","draft","keyName","keyId","pressed","handleKeyUp","addEventListener","removeEventListener","useKeyboard","viewXformMatrix","getViewXformMatrix","sceneDomElement","solver","createSolver","fps","React","prevTime","requestRef","timerRef","requestAnimationFrame","animate","time","delay","max","setTimeout","cancelAnimationFrame","clearTimeout","useAnimationFrame","Object","entries","Minus","exp","Equal","KeyH","KeyK","KeyU","KeyJ","func","handleViewControls","cartForceValue","KeyA","ArrowLeft","KeyD","ArrowRight","getExternalForceMap","newStateMap","animationDeltaTime","Date","getTime","floor","min","TARGET_PHYSICS_FPS","warn","error","getStateMap","simulate","onClick","initTfCpuBackend","initRsWasmModule","a","wasm","immer","init","then","ReactDOM","render","StrictMode","document","getElementById","main","navigator","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.3acdcd4d.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import * as tf from './tfjs';\n\nexport const ZERO_POS = tf.tensor2d([[0], [0], [1]]);\nexport const ZERO_VEL = tf.tensor2d([[0], [0], [0]]);\nexport const ZERO_STATE = [0, 0];\nexport const DEFAULT_TOLERANCE = 1e-6;\n\nexport class MissingArgumentError extends Error {}\nexport class NotImplementedError extends Error {}\nexport class DimensionError extends Error {}\nexport class SingularMatrixError extends Error {}\n\nexport function required(name) {\n  throw new MissingArgumentError(`Missing required function argument: ${name}`);\n}\n\nexport function coercePositionVector(position = required('position')) {\n  /**\n   * Convert the input argument into a tensor of shape `[3, 1]`, corresponding\n   * to an affine position vector where the final component is guaranteed to\n   * have a value of 1.\n   * @param {(number|number[]|tf.Tensor)} position\n   * @returns {tf.Tensor}\n   */\n  if (position instanceof tf.Tensor) {\n    const data = position.dataSync();\n    if (data.length < 2 || data.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` tensor to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor2d([[data[0]], [data[1]], [1]]);\n  } else if (position instanceof Array) {\n    if (position.length < 2 || position.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` array to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor2d([[position[0]], [position[1]], [1]]);\n  } else if (typeof position == 'number') {\n    position = tf.tensor2d([[position], [0], [1]]);\n  } else {\n    throw new TypeError(\n      `Expected \\`position\\` to be a number, array, or tf.Tensor instance; got ${position}`,\n    );\n  }\n  return position;\n}\n\nexport function coerceStateTuple(state = required('state')) {\n  /**\n   * Convert the input into a pair of numbers as a `[position, velocity]`\n   * list/tuple.\n   * @param {(number|number[])} state\n   * @returns {(number[])}\n   */\n  if (state == null) {\n    state = ZERO_STATE;\n  } else if (state === ZERO_STATE) {\n  } else if (typeof state == 'number') {\n    state = [state, 0];\n  } else if (state instanceof Array) {\n    if (state.length === 0 || state.length > 2) {\n      throw new DimensionError(\n        `Expected \\`state\\` tuple/array to have 1 or 2 elements; got ${state}`,\n      );\n    }\n    state = [state[0], state.length > 1 ? state[1] : 0];\n  } else {\n    throw new TypeError(\n      `Expected \\`state\\` to be tf.Tensor instance; got ${state}`,\n    );\n  }\n  return state;\n}\n\nexport function getScaleMatrix(x = required('x'), y = undefined) {\n  if (y == null) {\n    y = x;\n  }\n  return tf.tensor2d([\n    [x, 0, 0],\n    [0, y, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getRotationMatrix(angle = required('angle')) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, 0],\n    [s, c, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getTranslationMatrix(offset = required('offset')) {\n  offset = coercePositionVector(offset)\n  const offsetData = offset.dataSync();\n  offset.dispose();\n  return tf.tensor2d([\n    [1, 0, offsetData[0]],\n    [0, 1, offsetData[1]],\n    [0, 0, offsetData[2]],\n  ]);\n}\n\nexport function getRotationTranslationMatrix(\n  angle = required('angle'),\n  offset = required('offset'),\n) {\n  offset = coercePositionVector(offset);\n  const offsetData = offset.dataSync();\n  offset.dispose();\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, offsetData[0]],\n    [s, c, offsetData[1]],\n    [0, 0, offsetData[2]],\n  ]);\n}\n\nexport function checkXformMatrixShape(mat = required('mat')) {\n  if (!(mat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected transformation matrix \\`mat\\` to be tf.Tensor instance; got ${mat.toString()}`,\n    );\n  }\n  if (mat.shape.length !== 2 || mat.shape[0] !== 3 || mat.shape[1] !== 3) {\n    throw new DimensionError(\n      `Expected transformation matrix \\`mat\\` to have shape [3, 3]; got ${mat.toString()}`,\n    );\n  }\n}\n\nexport function getXformMatrixDeterminant(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return data[0] * data[4] - data[1] * data[3];\n}\n\nexport function getXformMatrixScaleFactor(mat = required('mat')) {\n  return Math.sqrt(Math.abs(getXformMatrixDeterminant(mat)));\n}\n\nexport function getXformMatrixRotationAngle(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return Math.atan2(data[1], -data[0]);\n}\n\nexport function getXformMatrixTranslation(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return tf.tensor2d([[data[2], data[5], data[8]]]);\n}\n\nexport function invertXformMatrix(mat = required('mat')) {\n  /**\n   * Invert a 3x3 transformation matrix.\n   */\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  const det =\n    data[0] * data[4] * data[8] +\n    data[1] * data[5] * data[6] +\n    data[2] * data[3] * data[7] -\n    data[0] * data[5] * data[7] -\n    data[1] * data[3] * data[8] -\n    data[2] * data[4] * data[6];\n  return tf.tensor2d([\n    [\n      +(data[4] * data[8] - data[5] * data[7]) / det,\n      -(data[1] * data[8] - data[2] * data[7]) / det,\n      +(data[1] * data[5] - data[2] * data[4]) / det,\n    ],\n    [\n      -(data[3] * data[8] - data[5] * data[6]) / det,\n      +(data[0] * data[8] - data[2] * data[6]) / det,\n      -(data[0] * data[5] - data[2] * data[3]) / det,\n    ],\n    [\n      +(data[3] * data[7] - data[4] * data[6]) / det,\n      -(data[0] * data[7] - data[1] * data[6]) / det,\n      +(data[0] * data[4] - data[1] * data[3]) / det,\n    ],\n  ]);\n}\n\nexport function solveLinearSystem(\n  aMat = required('aMat'),\n  bVec = required('bVec'),\n  { asTensor = true } = {},\n) {\n  /**\n   * Solve a linear system of equations using QR decomposition and\n   * back-substitution.\n   */\n  if (!(aMat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`aMat\\` to be tf.Tensor instance; got ${aMat}`,\n    );\n  } else if (!(bVec instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`bVec\\` to be tf.Tensor instance; got ${bVec}`,\n    );\n  } else if (aMat.shape.length !== 2 || aMat.shape[0] !== aMat.shape[1]) {\n    throw new DimensionError(\n      'Expected `aMat` to be a square matrix (2D tensor); ' +\n        `got tensor with shape ${JSON.stringify(aMat.shape)}`,\n    );\n  } else if (bVec.shape.length !== 2 || bVec.shape[1] !== 1) {\n    throw new DimensionError(\n      'Expected `bVec` to be a column vector (2D tensor with one column); ' +\n        `got tensor with shape ${JSON.stringify(bVec.shape)}`,\n    );\n  } else if (aMat.shape[1] !== bVec.shape[0]) {\n    throw new DimensionError(\n      'Expected `aMat` and `bVec` to have compatible shapes; ' +\n        `got aMat shape ${JSON.stringify(aMat.shape)} ` +\n        `and bVec shape ${JSON.stringify(bVec.shape)}`,\n    );\n  }\n  return tf.tidy(() => {\n    const n = bVec.shape[0];\n    const [qMat, rMat] = tf.linalg.qr(aMat);\n    const cVec = qMat.transpose().matMul(bVec).dataSync();\n    const rArray = rMat.arraySync();\n    const xArray = Array(n);\n    for (let i = n - 1; i >= 0; i--) {\n      if (Math.abs(rArray[i][i]) < DEFAULT_TOLERANCE) {\n        throw new SingularMatrixError(`Singular matrix: ${aMat.toString()}`);\n      }\n      let sum = 0;\n      for (let j = i + 1; j < n; j++) {\n        sum += rArray[i][j] * xArray[j];\n      }\n      xArray[i] = (cVec[i] - sum) / rArray[i][i];\n    }\n    return asTensor ? tf.tensor1d(xArray).reshape([n, 1]) : xArray;\n  });\n}\n\nexport function generateRandomId() {\n  /** See `https://gist.github.com/gordonbrander/2230317`.\n   */\n  return Math.random().toString(36).substr(2, 9);\n}\n","import { NotImplementedError } from './utils';\nimport { required } from './utils';\n\nexport default class Decal {\n  dispose() {}\n\n  xform(xformMatrix = required('xformMatrix')) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  toJsonObj() {\n    throw new NotImplementedError('TODO: implement');\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getRotationTranslationMatrix } from './utils';\nimport { getScaleMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nconst CENTERED_SQUARE = tf\n  .tensor2d([\n    [-0.5, -0.5, 1],\n    [0.5, -0.5, 1],\n    [0.5, 0.5, 1],\n    [-0.5, 0.5, 1],\n  ])\n  .transpose();\n\nconst QUAD1_SQUARE = tf\n  .tensor2d([\n    [0, 0, 1],\n    [1, 0, 1],\n    [1, 1, 1],\n    [0, 1, 1],\n  ])\n  .transpose();\n\nexport default class BoxDecal extends Decal {\n  constructor({\n    width = 1,\n    height = 1,\n    position = ZERO_POS,\n    angle = 0,\n    centered = true,\n    solid = true,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.width = width;\n    this.height = height;\n    this.position = coercePositionVector(position);\n    this.angle = angle;\n    this.centered = !!centered;\n    this.solid = !!solid;\n    this.lineWidth = lineWidth;\n    this.color = color;\n    this._cornerPositions = tf.tidy(() =>\n      getRotationTranslationMatrix(-angle, this.position)\n        .matMul(getScaleMatrix(width, height))\n        .matMul(centered ? CENTERED_SQUARE : QUAD1_SQUARE),\n    );\n  }\n\n  dispose() {\n    this._cornerPositions.dispose();\n    this.position.dispose();\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return new BoxDecal({\n      width: this.width * scale,\n      height: this.height * scale,\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      centered: this.centered,\n      solid: this.solid,\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    let element;\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    const cornerPositions = tf.tidy(() =>\n      xformMatrix.matMul(this._cornerPositions).arraySync(),\n    );\n    if (this.solid) {\n      element = (\n        <rect\n          x={cornerPositions[0][3]}\n          y={cornerPositions[1][3]}\n          width={this.width * scale}\n          height={this.height * scale}\n          key={key}\n        />\n      );\n    } else {\n      const npoints = this._cornerPositions.shape[1];\n      const lines = [];\n      for (let i = 0; i < npoints; i++) {\n        const j = (i + 1) % npoints;\n        lines.push(\n          <line\n            className=\"plot__line\"\n            x1={cornerPositions[0][i]}\n            y1={cornerPositions[1][i]}\n            x2={cornerPositions[0][j]}\n            y2={cornerPositions[1][j]}\n            strokeWidth={this.lineWidth * scale}\n            stroke={this.color}\n            key={i}\n          />,\n        );\n      }\n      element = <g key={key}>{lines}</g>;\n    }\n    return element;\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class CircleDecal extends Decal {\n  constructor({ position = ZERO_POS, radius = 1, color = 'black' } = {}) {\n    super();\n    this.position = coercePositionVector(position);\n    this.radius = radius;\n    this.color = color;\n  }\n\n  dispose() {\n    this.position.dispose();\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return CircleDecal({\n      position: xformMatrix.matMul(this.position),\n      radius: this.radius * scale,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const xformed = tf.tidy(() => xformMatrix.matMul(this.position).dataSync());\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <circle\n        className=\"plot__circle\"\n        cx={xformed[0]}\n        cy={xformed[1]}\n        r={this.radius * scale}\n        fill={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import { NotImplementedError } from './utils';\nimport { required } from './utils';\n\nexport class InvalidStateMapError extends Error {\n  constructor(message) {\n    super('Encountered invalid state map');\n    this.name = 'InvalidStateMapError';\n  }\n}\n\nexport function isValidStateMap(stateMap = required('stateMap')) {\n  return [...stateMap].every(([frameId, [q, qd]]) => !isNaN(q) && !isNaN(qd));\n}\n\nexport function checkStateMapValid(stateMap = required('stateMap')) {\n  if (!isValidStateMap(stateMap)) {\n    throw new InvalidStateMapError();\n  }\n}\n\nexport default class Solver {\n  constructor(scene = required('scene')) {\n    this.scene = scene;\n  }\n\n  dispose() {}\n\n  getStateMap() {\n    throw new NotImplementedError('abstract method');\n  }\n\n  setStateMap(stateMap = required('stateMap')) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  resetStateMap() {\n    this.setStateMap(this.scene.getInitialStateMap());\n  }\n\n  tick(\n    deltaTime = required('deltaTime'),\n    tickCount = 1,\n    externalForceMap = null,\n  ) {\n    throw new NotImplementedError('abstract method');\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class LineDecal extends Decal {\n  constructor({\n    endPos = required('endPos'),\n    startPos = ZERO_POS,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.startPos = coercePositionVector(startPos);\n    this.endPos = coercePositionVector(endPos);\n    this.lineWidth = lineWidth;\n    this.color = color;\n  }\n\n  dispose() {\n    this.startPos.dispose();\n    this.endPos.dispose();\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return LineDecal({\n      endPos: xformMatrix.matMul(this.endPos),\n      startPos: xformMatrix.matMul(this.startPos),\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const startPos = tf.tidy(() => xformMatrix.matMul(this.startPos).dataSync());\n    const endPos = tf.tidy(() => xformMatrix.matMul(this.endPos).dataSync());\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <line\n        className=\"plot__line\"\n        x1={startPos[0]}\n        y1={startPos[1]}\n        x2={endPos[0]}\n        y2={endPos[1]}\n        strokeWidth={this.lineWidth * scale}\n        stroke={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { coerceStateTuple } from './utils';\nimport { generateRandomId } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n    typeName = null,\n  } = {}) {\n    this.id = id != null ? id : generateRandomId();\n    this.typeName = typeName || this.constructor.name;\n    this.position = coercePositionVector(position);\n    this.decals = decals;\n    this.weights = weights;\n    this.frames = frames;\n    this.resistance = resistance;\n    this.initialState = coerceStateTuple(initialState);\n  }\n\n  dispose() {\n    this.frames.forEach((frame) => frame.dispose());\n    this.weights.forEach((weight) => weight.dispose());\n    this.decals.forEach((decals) => decals.dispose());\n    this.position.dispose();\n  }\n\n  getLocalPosMatrix(q = required('q')) {\n    return tf.eye(3);\n  }\n\n  getLocalVelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getLocalAccelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const [q] = stateMap.has(this.id) ? stateMap.get(this.id) : ZERO_STATE;\n    xformMatrix = tf.tidy(() => xformMatrix.matMul(this.getLocalPosMatrix(q)));\n    const domElement = (\n      <g className=\"frame\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, {\n            key: 'frame' + index,\n          }),\n        )}\n      </g>\n    );\n    xformMatrix.dispose();\n    return domElement;\n  }\n\n  toJsonObj({ includeDecals = false } = {}) {\n    const obj = {\n      frames: this.frames.map((frame) =>\n        frame.toJsonObj({ includeDecals: includeDecals }),\n      ),\n      id: this.id,\n      initialState: this.initialState,\n      position: tf.tidy(() => [...this.position.dataSync().slice(0, -1)]),\n      resistance: this.resistance,\n      type: this.typeName,\n      weights: this.weights.map((weight) => weight.toJsonObj()),\n    };\n    if (includeDecals) {\n      obj.decals = this.decals.map((decal) => decal.toJsonObj());\n    }\n    return obj;\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class RotationalFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n  } = {}) {\n    super({\n      decals: decals,\n      frames: frames,\n      id: id,\n      initialState: initialState,\n      position: position,\n      resistance: resistance,\n      typeName: 'RotationalFrame',\n      weights: weights,\n    });\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new RotationalFrame({\n      position: xformMatrix.matMul(this.position),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getLocalPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [c, -s, position[0]],\n      [s, c, position[1]],\n      [0, 0, 1],\n    ]);\n  }\n\n  getLocalVelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-s, -c, 0],\n      [c, -s, 0],\n      [0, 0, 0],\n    ]);\n  }\n\n  getLocalAccelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-c, s, 0],\n      [-s, -c, 0],\n      [0, 0, 0],\n    ]);\n  }\n}\n","import Solver from './Solver';\nimport { InvalidStateMapError } from './Solver';\nimport { required } from './utils';\n\nexport default class RsSolver extends Solver {\n  constructor(\n    scene = required('scene'),\n    rsWasmModule = required('rsWasmModule'),\n    { rungeKutta = true } = {},\n  ) {\n    super(scene);\n    this.stateBuffer = new Float64Array(this.scene.sortedFrames.length * 2);\n    this.extForceBuffer = new Float64Array(this.scene.sortedFrames.length);\n    this.resetStateMap();\n    console.log('[js] Creating solver context');\n    const sceneJson = JSON.stringify(scene.toJsonObj());\n    this.context = new rsWasmModule.SolverContext(sceneJson);\n    this.context.setRungeKutta(rungeKutta);\n    console.log('[js] Created solver context:', this.context);\n  }\n\n  dispose() {\n    console.log('[js] Disposing solver context');\n    this.context.dispose();\n    console.log('[js] Disposed solver context');\n    this.context = null;\n  }\n\n  getStateMap() {\n    return new Map(\n      this.scene.sortedFrames.map((frame, index) => [\n        frame.id,\n        [this.stateBuffer[index * 2], this.stateBuffer[index * 2 + 1]],\n      ]),\n    );\n  }\n\n  setStateMap(stateMap = required('stateMap')) {\n    this.stateBuffer.set(\n      this.scene.sortedFrames.flatMap(\n        (frame) => stateMap.get(frame.id) || [0, 0],\n      ),\n    );\n  }\n\n  tick(\n    deltaTime = required('deltaTime'),\n    tickCount = 1,\n    externalForceMap = null,\n  ) {\n    this.extForceBuffer.set(\n      this.scene.sortedFrames.map((frame) =>\n        externalForceMap ? externalForceMap.get(frame.id) || 0 : 0,\n      ),\n    );\n    this.context.tick(this.stateBuffer, deltaTime, tickCount, this.extForceBuffer);\n    for (let i = 0; i < this.stateBuffer.length; i++) {\n      if (isNaN(this.stateBuffer[i])) {\n        throw new InvalidStateMapError();\n      }\n    }\n  }\n}\n","export const defaultGetNodeParents = (x) => x.parents;\nexport const defaultGetNodeKey = (x) => x;\n\nexport function toposort(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {}\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const markedNodes = new Set();\n  const sortedNodes = [];\n  const sortedKeys = [];\n\n  function visit(node, child) {\n    const nodeKey = getNodeKey(node);\n    if (markedNodes.has(nodeKey)) {\n      throw new Error(`Graph is not a DAG; recursively encountered ${node}`);\n    }\n    if (!sortedKeys.includes(nodeKey)) {\n      const parents = getNodeParents(node);\n      if (parents) {\n        markedNodes.add(nodeKey);\n        parents.forEach((parent) => visit(parent, node));\n        markedNodes.delete(nodeKey);\n        sortedNodes.push(node);\n        sortedKeys.push(nodeKey);\n      }\n    }\n  }\n\n  [...nodes].forEach((node) => visit(node, null));\n  return sortedNodes;\n}\n\nexport function getChildMap(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {}\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const childMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parents = getNodeParents(node);\n    childMap.has(nodeKey) || childMap.set(nodeKey, new Set());\n    parents.forEach((parent) => {\n      const parentKey = getNodeKey(parent);\n      childMap.has(parentKey) || childMap.set(parentKey, new Set());\n      childMap.get(parentKey).add(node);\n    });\n  });\n  return childMap;\n}\n\nexport function transform(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n    visitEdge = undefined,\n  } = {}\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  visitNode = visitNode || ((node, parentValues) => null);\n  visitEdge = visitEdge || ((node, parentNode, parentValue) => parentValue);\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const nodeMap = new Map();\n  const edgeMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parentNodes = getNodeParents(node);\n    const parentEdgeValues = parentNodes.map((parentNode) => {\n      const parentNodeKey = getNodeKey(parentNode);\n      const edgeValue = visitEdge(node, parentNode, nodeMap.get(parentNodeKey));\n      edgeMap.set([parentNodeKey, nodeKey], edgeValue);\n      return edgeValue;\n    });\n    const nodeValue = visitNode(node, parentEdgeValues);\n    nodeMap.set(nodeKey, nodeValue);\n  });\n  return [nodeMap, edgeMap];\n}\n\nexport function transformNodes(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n  } = {}\n) {\n  const [nodeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitNode: visitNode,\n  });\n  return nodeMap;\n}\n\nexport function transformEdges(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitEdge = undefined,\n  } = {}\n) {\n  const [, edgeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitEdge: visitEdge,\n  });\n  return edgeMap;\n}\n","import * as daglet from './daglet';\nimport * as tf from './tfjs';\nimport React from 'react';\nimport { required } from './utils';\n\nexport const DEFAULT_GRAVITY = 10;\n\nexport default class Scene {\n  constructor({\n    decals = [],\n    frames = [],\n    springs = [],\n    constraints = [],\n    gravity = DEFAULT_GRAVITY,\n  } = {}) {\n    this.decals = decals;\n    this.frames = frames;\n    this.springs = springs;\n    this.constraints = constraints;\n    this.gravity = gravity;\n\n    const getFrameChildren = (frame) => frame.frames;\n    const getFrameId = (frame) => frame.id;\n    this.sortedFrames = daglet\n      .toposort(this.frames, {\n        getNodeParents: getFrameChildren,\n        getNodeKey: getFrameId,\n      })\n      .reverse();\n    this.frameMap = new Map(\n      this.sortedFrames.map((frame) => [frame.id, frame]),\n    );\n    const frameIdParentsMap = daglet.getChildMap(this.sortedFrames, {\n      getNodeParents: getFrameChildren,\n      getNodeKey: getFrameId,\n    });\n    if ([...frameIdParentsMap.values()].some((parents) => parents.size > 1)) {\n      throw new Error('Frames should only have one parent'); // TODO: use AssertionError?\n    }\n    this.frameIdParentMap = new Map(\n      [...frameIdParentsMap].map(([frameId, parents]) => [\n        frameId,\n        parents.size ? [...parents][0].id : null,\n      ]),\n    );\n    this.frameIdPathMap = daglet.transformNodes(this.sortedFrames, {\n      getNodeParents: (frame) => [...frameIdParentsMap.get(frame.id)],\n      getNodeKey: getFrameId,\n      visitNode: (frame, parentPaths) =>\n        parentPaths.length ? [...parentPaths[0], frame.id] : [frame.id],\n    });\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = tf.eye(3),\n    { key = undefined } = {},\n  ) {\n    return (\n      <g className=\"scene\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, { key: 'frame' + index }),\n        )}\n      </g>\n    );\n  }\n\n  getInitialStateMap({ randomize = false } = {}) {\n    let getInitialState;\n    if (randomize) {\n      const randPi = () => (Math.random() - 0.5) * Math.PI * 2; // TBD\n      getInitialState = (frame) => [randPi(), randPi()];\n    } else {\n      getInitialState = (frame) => frame.initialState;\n    }\n    return new Map(\n      this.sortedFrames.map((frame) => [frame.id, getInitialState(frame)]),\n    );\n  }\n\n  toJsonObj({includeDecals = false} = {}) {\n    const obj = {\n      frames: this.frames.map((frame) => frame.toJsonObj({includeDecals: includeDecals})),\n      gravity: this.gravity,\n    }\n    if (includeDecals) {\n      obj.decals = this.decals.map((decal) => decal.toJsonObj())\n    }\n    return obj;\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { getTranslationMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class TrackFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    angle = 0,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = undefined,\n  } = {}) {\n    super({\n      angle: angle,\n      decals: decals,\n      frames: frames,\n      id: id,\n      initialState: initialState,\n      position: position,\n      resistance: resistance,\n      typeName: 'TrackFrame',\n      weights: weights,\n    });\n    this.angle = angle;\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new TrackFrame({\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getLocalPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    return getTranslationMatrix([\n      position[0] + q * Math.cos(this.angle),\n      position[1] + q * Math.sin(this.angle),\n    ]);\n  }\n\n  getLocalVelMatrix(q = required('q')) {\n    return tf.tensor2d([\n      [0, 0, Math.cos(this.angle)],\n      [0, 0, Math.sin(this.angle)],\n      [0, 0, 0],\n    ]);\n  }\n\n  toJsonObj(options = {}) {\n    return { angle: this.angle, ...super.toJsonObj(options) };\n  }\n}\n","import * as tf from './tfjs';\nimport { coercePositionVector } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class Weight {\n  constructor(mass = 1, { position = ZERO_POS, drag = 0 } = {}) {\n    this.mass = mass;\n    this.position = coercePositionVector(position);\n    this.drag = drag;\n  }\n\n  dispose() {\n    this.position.dispose();\n  }\n\n  xform(xformMatrix) {\n    return new Weight({\n      mass: this.mass,\n      position: xformMatrix.matMul(this.position),\n      drag: this.drag,\n    });\n  }\n\n  toJsonObj() {\n    return {\n      mass: this.mass,\n      position: tf.tidy(() => [...this.position.dataSync().slice(0, 2)]),\n      drag: this.drag,\n    }\n  }\n}\n","import './App.css';\nimport 'normalize.css';\nimport * as tf from './tfjs';\nimport BoxDecal from './BoxDecal';\nimport CircleDecal from './CircleDecal';\nimport JsSolver from './JsSolver';\nimport LineDecal from './LineDecal';\nimport producer from 'immer';\nimport React from 'react';\nimport RotationalFrame from './RotationalFrame';\nimport RsSolver from './RsSolver';\nimport Scene from './Scene';\nimport TrackFrame from './TrackFrame';\nimport Weight from './Weight';\nimport { getScaleMatrix } from './utils';\nimport { getTranslationMatrix } from './utils';\nimport { required } from './utils';\nimport { useEffect } from 'react';\nimport { useRef } from 'react';\nimport { useState } from 'react';\nimport { InvalidStateMapError } from './Solver';\n\nconst poiMass = 60;\nconst poiDrag = 20;\nconst ropeSegmentLength = 1.2;\nconst ropeSegmentDrag = 8;\nconst ropeSegmentMass = 1;\nconst ropeSegmentResistance = 10;\nconst ropeSegmentCount = 10;\nconst cartMass = 250;\nconst cartForce = 8500;\nconst cartResistance = 5;\n\nconst initialScale = 12;\nconst MIN_ANIMATION_FPS = 5;\nconst TARGET_ANIMATION_FPS = 60;\nconst TIME_SCALE = 1.5;\nconst TARGET_PHYSICS_FPS = 300 * TIME_SCALE;\n\nconst segments = Array(ropeSegmentCount)\n  .fill()\n  .map((x, index) => index)\n  .reduce((childFrames, index) => {\n    const first = index === 0;\n    const last = index === ropeSegmentCount - 1;\n    const radius = first ? 1 : 0.38 / 2;\n    const mass = first ? poiMass : ropeSegmentMass;\n    const drag = first ? poiDrag : ropeSegmentDrag;\n    const weights = [\n      new Weight(mass, {\n        position: [ropeSegmentLength, 0],\n        drag: drag,\n      }),\n    ];\n    const decals = [\n      new LineDecal({\n        endPos: [ropeSegmentLength * 1.1, 0],\n        lineWidth: 0.38,\n      }),\n    ];\n    if (first || true) {\n      decals.push(\n        new CircleDecal({\n          position: [ropeSegmentLength, 0],\n          radius: radius,\n        }),\n      );\n    }\n    return [\n      new RotationalFrame({\n        id: `segment${index}`,\n        initialState: last ? [Math.PI * 0.3, 0] : [0, 0],\n        decals: decals,\n        frames: childFrames,\n        position: [last ? 0 : ropeSegmentLength, 0],\n        weights: weights,\n        resistance: ropeSegmentResistance,\n      }),\n    ];\n  }, []);\n\nconst cart = new TrackFrame({\n  id: 'cart',\n  decals: [\n    new BoxDecal({\n      width: 3,\n      height: 3 / 1.618,\n      //color: 'blue',\n      lineWidth: 0.2,\n    }),\n  ],\n  frames: segments,\n  initialState: [0, 0],\n  weights: [new Weight(cartMass)],\n  resistance: cartResistance,\n});\n\nconst scene = new Scene({\n  frames: [cart],\n  decals: [\n    new LineDecal({\n      startPos: [-300, 0],\n      endPos: [300, 0],\n      color: 'gray',\n      lineWidth: 0.1,\n    }),\n  ],\n});\n\nfunction useKeyboard(callback = null) {\n  const [pressedKeys, setPressedKeys] = useState(new Set());\n  const callbackRef = useRef();\n  callbackRef.current = callback;\n\n  useEffect(() => {\n    function handleKeyDown({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (!pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.add(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: true,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n    function handleKeyUp({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.delete(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: false,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n\n  return pressedKeys;\n}\n\nconst useAnimationFrame = (callback, { fps = TARGET_ANIMATION_FPS } = {}) => {\n  const state = React.useRef({ prevTime: 0 });\n  const requestRef = React.useRef();\n  const timerRef = React.useRef();\n  state.current.callback = callback;\n\n  React.useEffect(() => {\n    function animate(time = required('time')) {\n      const deltaTime = (time - state.current.prevTime) / 1000;\n      const delay = Math.max(1000 / fps - deltaTime, 0);\n      state.current.callback(deltaTime);\n      state.current.prevTime = time;\n      timerRef.current = setTimeout(() => {\n        requestRef.current = requestAnimationFrame(animate);\n      }, delay);\n    }\n\n    requestRef.current = requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n      timerRef.current && clearTimeout(timerRef.current);\n    };\n  }, [fps]);\n};\n\nfunction handleViewControls({\n  deltaTime = required('deltaTime'),\n  pressedKeys = required('pressedKeys'),\n  scale = required('scale'),\n  setScale = required('setScale'),\n  setTranslation = required('setTranslation'),\n  translation = required('translation'),\n} = {}) {\n  Object.entries({\n    Minus: () => setScale(scale * Math.exp(-deltaTime)),\n    Equal: () => setScale(scale * Math.exp(deltaTime)),\n    KeyH: () => setTranslation(([x, y]) => [x + deltaTime * 20, y]),\n    KeyK: () => setTranslation(([x, y]) => [x - deltaTime * 20, y]),\n    KeyU: () => setTranslation(([x, y]) => [x, y - deltaTime * 20]),\n    KeyJ: () => setTranslation(([x, y]) => [x, y + deltaTime * 20]),\n  }).forEach(([keyName, func]) => pressedKeys.has(keyName) && func());\n}\n\nfunction getExternalForceMap(pressedKeys, deltaTime) {\n  let cartForceValue = 0;\n  Object.entries({\n    KeyA: () => {\n      cartForceValue -= cartForce;\n    },\n    ArrowLeft: () => {\n      cartForceValue -= cartForce;\n    },\n    KeyD: () => {\n      cartForceValue += cartForce;\n    },\n    ArrowRight: () => {\n      cartForceValue += cartForce;\n    },\n  }).forEach(([keyName, func]) => pressedKeys.has(keyName) && func());\n  return new Map([[cart.id, cartForceValue]]);\n}\n\nfunction simulate(\n  solver = required('solver'),\n  externalForceMap = required('externalForceMap'),\n  animationDeltaTime = required('animationDeltaTime'),\n) {\n  const startTime = new Date().getTime();\n  const deltaTime = TIME_SCALE / TARGET_PHYSICS_FPS;\n  let tickCount = Math.floor(\n    Math.min(animationDeltaTime / deltaTime, TARGET_PHYSICS_FPS),\n  );\n  if (animationDeltaTime > 1 / MIN_ANIMATION_FPS) {\n    tickCount = Math.floor(\n      Math.min(tickCount, TARGET_PHYSICS_FPS / MIN_ANIMATION_FPS),\n    );\n    console.warn(\n      `Falling below minimum desired animation FPS; limiting simulation to ${tickCount} ticks`,\n    );\n  }\n  try {\n    solver.tick(\n      deltaTime,\n      Math.min(tickCount, TARGET_PHYSICS_FPS),\n      externalForceMap,\n    );\n  } catch (error) {\n    if (error instanceof InvalidStateMapError) {\n      console.warn(\n        'Encountered invalid state map; resetting to initial state...',\n      );\n      solver.resetStateMap();\n    } else {\n      throw error;\n    }\n  }\n  return solver.getStateMap();\n}\n\nfunction getViewXformMatrix(translation, scale) {\n  return tf.tidy(() =>\n    getTranslationMatrix([300, 300])\n      .matMul(getScaleMatrix(scale, -scale))\n      .matMul(getTranslationMatrix(translation)),\n  );\n}\n\nfunction createSolver(\n  scene = required('scene'),\n  rsWasmModule = required('rsWasmModule'),\n) {\n  //console.log('[js] Creating solver');\n  //const solver = new JsSolver(scene, { rungeKutta: false });\n  const solver = new RsSolver(scene, rsWasmModule, { rungeKutta: true });\n  window.solver = solver; // (for debugging)\n  //console.log('[js] Solver:', solver);\n  return solver;\n}\n\nfunction App({ rsWasmModule }) {\n  const [paused, setPaused] = useState(false);\n  const [translation, setTranslation] = useState([0, 0]);\n  const [scale, setScale] = useState(initialScale);\n  const pressedKeys = useKeyboard();\n  const [stateMap, setStateMap] = useState(scene.getInitialStateMap());\n  const viewXformMatrix = getViewXformMatrix(translation, scale);\n  const sceneDomElement = scene.getDomElement(stateMap, viewXformMatrix);\n  viewXformMatrix.dispose();\n  const solver = useRef(null);\n\n  useEffect(() => {\n    solver.current = createSolver(scene, rsWasmModule);\n  }, [rsWasmModule]);\n\n  useAnimationFrame((deltaTime) => {\n    handleViewControls({\n      deltaTime,\n      pressedKeys,\n      scale,\n      setScale,\n      setTranslation,\n      translation,\n    });\n    if (!paused) {\n      const externalForceMap = getExternalForceMap(pressedKeys, deltaTime);\n      const newStateMap = simulate(solver.current, externalForceMap, deltaTime);\n      setStateMap(newStateMap);\n    }\n  });\n\n  const togglePaused = () => {\n    setPaused(!paused);\n  };\n\n  return (\n    <div className=\"app__main\">\n      <div className=\"plot\">\n        <h2 className=\"plot__title\">CartPoi</h2>\n        {\n          //<p>Number of tensors: {tf.memory().numTensors}</p>\n        }\n        {\n          //<p>Keys: {[...pressedKeys].join(', ')}</p>\n        }\n        {\n          //<p>Scale: {scale.toFixed(2)}</p>\n        }\n        <div className=\"plot__main\">\n          <svg className=\"plot__svg\">{sceneDomElement}</svg>\n        </div>\n        <button onClick={togglePaused}>{paused ? 'Unpause' : 'Pause'}</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import './index.css';\nimport * as immer from 'immer';\nimport * as serviceWorker from './serviceWorker';\nimport * as tf from '@tensorflow/tfjs';\nimport * as tfWasm from '@tensorflow/tfjs-backend-wasm';\nimport App from './App';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimmer.enableMapSet();\n\nwindow.tf = tf; // (for debugging)\n\nfunction initTfCpuBackend() {\n  tf.setBackend('cpu');\n}\n\nfunction initTfWebGLBackend() {\n  tf.env().set('WEBGL_CPU_FORWARD', false);\n  tf.setBackend('webgl');\n}\n\nasync function initTfWasmBackend() {\n  tfWasm.setWasmPaths('/');\n  await tf.setBackend('wasm');\n}\n\nasync function initRsWasmModule() {\n  const rsWasmModule = await import('physm-rs');\n  window.wasm = rsWasmModule; // (for debugging)\n  return rsWasmModule;\n}\n\nasync function init() {\n  tf.enableProdMode();\n  initTfCpuBackend();\n  //initTfWebGLBackend();\n  //await initTfWasmBackend();\n  return await initRsWasmModule();\n}\n\nfunction main(rsWasmModule) {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App rsWasmModule={rsWasmModule} />\n    </React.StrictMode>,\n    document.getElementById('root'),\n  );\n}\n\ninit().then((rsWasmModule) => main(rsWasmModule));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}