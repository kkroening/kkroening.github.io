{"version":3,"sources":["serviceWorker.js","utils.js","Decal.js","BoxDecal.js","CircleDecal.js","LineDecal.js","Frame.js","RotationalFrame.js","Solver.js","RsSolver.js","daglet.js","Scene.js","TrackFrame.js","Weight.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","ZERO_POS","tf","ZERO_STATE","MissingArgumentError","Error","NotImplementedError","DimensionError","required","name","coercePositionVector","position","data","dataSync","length","Array","TypeError","coerceStateTuple","state","getScaleMatrix","x","y","undefined","getTranslationMatrix","offset","offsetData","dispose","getRotationTranslationMatrix","angle","c","Math","cos","s","sin","checkXformMatrixShape","mat","toString","shape","getXformMatrixDeterminant","getXformMatrixScaleFactor","sqrt","abs","getXformMatrixRotationAngle","atan2","generateRandomId","random","substr","Decal","key","CENTERED_SQUARE","transpose","QUAD1_SQUARE","BoxDecal","width","height","centered","solid","lineWidth","color","_cornerPositions","matMul","this","xformMatrix","scale","element","cornerPositions","arraySync","npoints","lines","i","j","push","className","x1","y1","x2","y2","strokeWidth","stroke","CircleDecal","radius","xformed","cx","cy","r","fill","LineDecal","endPos","startPos","Frame","decals","weights","frames","resistance","initialState","id","typeName","constructor","forEach","frame","weight","stateMap","has","get","q","getLocalPosMatrix","domElement","map","decal","index","getDomElement","includeDecals","obj","toJsonObj","slice","type","RotationalFrame","InvalidStateMapError","message","RsSolver","scene","rsWasmModule","rungeKutta","stateBuffer","Float64Array","sortedFrames","extForceBuffer","resetStateMap","console","log","sceneJson","JSON","stringify","context","SolverContext","setRungeKutta","Map","set","flatMap","deltaTime","tickCount","externalForceMap","tick","isNaN","setStateMap","getInitialStateMap","defaultGetNodeParents","parents","defaultGetNodeKey","toposort","nodes","getNodeParents","getNodeKey","markedNodes","Set","sortedNodes","sortedKeys","visit","node","child","nodeKey","includes","add","parent","delete","getChildMap","childMap","parentKey","transform","visitNode","visitEdge","parentValues","parentNode","parentValue","nodeMap","edgeMap","parentEdgeValues","parentNodeKey","edgeValue","nodeValue","transformNodes","Scene","springs","constraints","gravity","getFrameChildren","getFrameId","daglet","reverse","frameMap","frameIdParentsMap","values","some","size","frameIdParentMap","frameId","frameIdPathMap","parentPaths","getInitialState","randomize","randPi","PI","TrackFrame","options","Weight","mass","drag","segments","ropeNum","reduce","childSegment","first","last","ropeSegmentCount","stick","stickLength","cart","App","useState","paused","setPaused","translation","setTranslation","setScale","svgRef","React","useRef","pressedKeys","callback","setPressedKeys","callbackRef","current","useEffect","handleKeyDown","code","keyCode","producer","draft","keyName","keyId","pressed","handleKeyUp","addEventListener","removeEventListener","useKeyboard","clickLocationDelta","elementRef","startLocation","setStartLocation","endLocation","setEndLocation","handleMouseDown","event","handleMouseMove","handleMouseUp","locationDelta","useMouse","touchLocationDelta","handleTouchStart","which","touches","clientX","clientY","preventDefault","handleTouchMove","handleTouchEnd","useTouch","viewXformMatrix","getViewXformMatrix","sceneDomElement","solver","createSolver","fps","prevTime","requestRef","timerRef","requestAnimationFrame","animate","time","delay","max","setTimeout","cancelAnimationFrame","clearTimeout","useAnimationFrame","Object","entries","Minus","exp","Equal","KeyH","KeyK","KeyU","KeyJ","func","handleViewControls","cartForce","sign","getExternalForceMap","newStateMap","animationDeltaTime","TIME_SCALE","floor","min","TARGET_PHYSICS_FPS","warn","error","getStateMap","simulate","ref","onClick","initTfCpuBackend","initRsWasmModule","a","wasm","immer","init","then","ReactDOM","render","StrictMode","document","getElementById","main","navigator","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.20c2e529.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import * as tf from './tfjs';\n\nexport const ZERO_POS = tf.tensor2d([[0], [0], [1]]);\nexport const ZERO_VEL = tf.tensor2d([[0], [0], [0]]);\nexport const ZERO_STATE = [0, 0];\nexport const DEFAULT_TOLERANCE = 1e-6;\n\nexport class MissingArgumentError extends Error {}\nexport class NotImplementedError extends Error {}\nexport class DimensionError extends Error {}\nexport class SingularMatrixError extends Error {}\n\nexport function required(name) {\n  throw new MissingArgumentError(`Missing required function argument: ${name}`);\n}\n\nexport function coercePositionVector(position = required('position')) {\n  /**\n   * Convert the input argument into a tensor of shape `[3, 1]`, corresponding\n   * to an affine position vector where the final component is guaranteed to\n   * have a value of 1.\n   * @param {(number|number[]|tf.Tensor)} position\n   * @returns {tf.Tensor}\n   */\n  if (position instanceof tf.Tensor) {\n    const data = position.dataSync();\n    if (data.length < 2 || data.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` tensor to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor2d([[data[0]], [data[1]], [1]]);\n  } else if (position instanceof Array) {\n    if (position.length < 2 || position.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` array to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor2d([[position[0]], [position[1]], [1]]);\n  } else if (typeof position == 'number') {\n    position = tf.tensor2d([[position], [0], [1]]);\n  } else {\n    throw new TypeError(\n      `Expected \\`position\\` to be a number, array, or tf.Tensor instance; got ${position}`,\n    );\n  }\n  return position;\n}\n\nexport function coerceStateTuple(state = required('state')) {\n  /**\n   * Convert the input into a pair of numbers as a `[position, velocity]`\n   * list/tuple.\n   * @param {(number|number[])} state\n   * @returns {(number[])}\n   */\n  if (state == null) {\n    state = ZERO_STATE;\n  } else if (state === ZERO_STATE) {\n  } else if (typeof state == 'number') {\n    state = [state, 0];\n  } else if (state instanceof Array) {\n    if (state.length === 0 || state.length > 2) {\n      throw new DimensionError(\n        `Expected \\`state\\` tuple/array to have 1 or 2 elements; got ${state}`,\n      );\n    }\n    state = [state[0], state.length > 1 ? state[1] : 0];\n  } else {\n    throw new TypeError(\n      `Expected \\`state\\` to be tf.Tensor instance; got ${state}`,\n    );\n  }\n  return state;\n}\n\nexport function getScaleMatrix(x = required('x'), y = undefined) {\n  if (y == null) {\n    y = x;\n  }\n  return tf.tensor2d([\n    [x, 0, 0],\n    [0, y, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getRotationMatrix(angle = required('angle')) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, 0],\n    [s, c, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getTranslationMatrix(offset = required('offset')) {\n  offset = coercePositionVector(offset)\n  const offsetData = offset.dataSync();\n  offset.dispose();\n  return tf.tensor2d([\n    [1, 0, offsetData[0]],\n    [0, 1, offsetData[1]],\n    [0, 0, offsetData[2]],\n  ]);\n}\n\nexport function getRotationTranslationMatrix(\n  angle = required('angle'),\n  offset = required('offset'),\n) {\n  offset = coercePositionVector(offset);\n  const offsetData = offset.dataSync();\n  offset.dispose();\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, offsetData[0]],\n    [s, c, offsetData[1]],\n    [0, 0, offsetData[2]],\n  ]);\n}\n\nexport function checkXformMatrixShape(mat = required('mat')) {\n  if (!(mat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected transformation matrix \\`mat\\` to be tf.Tensor instance; got ${mat.toString()}`,\n    );\n  }\n  if (mat.shape.length !== 2 || mat.shape[0] !== 3 || mat.shape[1] !== 3) {\n    throw new DimensionError(\n      `Expected transformation matrix \\`mat\\` to have shape [3, 3]; got ${mat.toString()}`,\n    );\n  }\n}\n\nexport function getXformMatrixDeterminant(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return data[0] * data[4] - data[1] * data[3];\n}\n\nexport function getXformMatrixScaleFactor(mat = required('mat')) {\n  return Math.sqrt(Math.abs(getXformMatrixDeterminant(mat)));\n}\n\nexport function getXformMatrixRotationAngle(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return Math.atan2(data[1], -data[0]);\n}\n\nexport function getXformMatrixTranslation(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return tf.tensor2d([[data[2], data[5], data[8]]]);\n}\n\nexport function invertXformMatrix(mat = required('mat')) {\n  /**\n   * Invert a 3x3 transformation matrix.\n   */\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  const det =\n    data[0] * data[4] * data[8] +\n    data[1] * data[5] * data[6] +\n    data[2] * data[3] * data[7] -\n    data[0] * data[5] * data[7] -\n    data[1] * data[3] * data[8] -\n    data[2] * data[4] * data[6];\n  return tf.tensor2d([\n    [\n      +(data[4] * data[8] - data[5] * data[7]) / det,\n      -(data[1] * data[8] - data[2] * data[7]) / det,\n      +(data[1] * data[5] - data[2] * data[4]) / det,\n    ],\n    [\n      -(data[3] * data[8] - data[5] * data[6]) / det,\n      +(data[0] * data[8] - data[2] * data[6]) / det,\n      -(data[0] * data[5] - data[2] * data[3]) / det,\n    ],\n    [\n      +(data[3] * data[7] - data[4] * data[6]) / det,\n      -(data[0] * data[7] - data[1] * data[6]) / det,\n      +(data[0] * data[4] - data[1] * data[3]) / det,\n    ],\n  ]);\n}\n\nexport function solveLinearSystem(\n  aMat = required('aMat'),\n  bVec = required('bVec'),\n  { asTensor = true } = {},\n) {\n  /**\n   * Solve a linear system of equations using QR decomposition and\n   * back-substitution.\n   */\n  if (!(aMat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`aMat\\` to be tf.Tensor instance; got ${aMat}`,\n    );\n  } else if (!(bVec instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`bVec\\` to be tf.Tensor instance; got ${bVec}`,\n    );\n  } else if (aMat.shape.length !== 2 || aMat.shape[0] !== aMat.shape[1]) {\n    throw new DimensionError(\n      'Expected `aMat` to be a square matrix (2D tensor); ' +\n        `got tensor with shape ${JSON.stringify(aMat.shape)}`,\n    );\n  } else if (bVec.shape.length !== 2 || bVec.shape[1] !== 1) {\n    throw new DimensionError(\n      'Expected `bVec` to be a column vector (2D tensor with one column); ' +\n        `got tensor with shape ${JSON.stringify(bVec.shape)}`,\n    );\n  } else if (aMat.shape[1] !== bVec.shape[0]) {\n    throw new DimensionError(\n      'Expected `aMat` and `bVec` to have compatible shapes; ' +\n        `got aMat shape ${JSON.stringify(aMat.shape)} ` +\n        `and bVec shape ${JSON.stringify(bVec.shape)}`,\n    );\n  }\n  return tf.tidy(() => {\n    const n = bVec.shape[0];\n    const [qMat, rMat] = tf.linalg.qr(aMat);\n    const cVec = qMat.transpose().matMul(bVec).dataSync();\n    const rArray = rMat.arraySync();\n    const xArray = Array(n);\n    for (let i = n - 1; i >= 0; i--) {\n      if (Math.abs(rArray[i][i]) < DEFAULT_TOLERANCE) {\n        throw new SingularMatrixError(`Singular matrix: ${aMat.toString()}`);\n      }\n      let sum = 0;\n      for (let j = i + 1; j < n; j++) {\n        sum += rArray[i][j] * xArray[j];\n      }\n      xArray[i] = (cVec[i] - sum) / rArray[i][i];\n    }\n    return asTensor ? tf.tensor1d(xArray).reshape([n, 1]) : xArray;\n  });\n}\n\nexport function generateRandomId() {\n  /** See `https://gist.github.com/gordonbrander/2230317`.\n   */\n  return Math.random().toString(36).substr(2, 9);\n}\n","import { NotImplementedError } from './utils';\nimport { required } from './utils';\n\nexport default class Decal {\n  dispose() {}\n\n  xform(xformMatrix = required('xformMatrix')) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  toJsonObj() {\n    throw new NotImplementedError('TODO: implement');\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getRotationTranslationMatrix } from './utils';\nimport { getScaleMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nconst CENTERED_SQUARE = tf\n  .tensor2d([\n    [-0.5, -0.5, 1],\n    [0.5, -0.5, 1],\n    [0.5, 0.5, 1],\n    [-0.5, 0.5, 1],\n  ])\n  .transpose();\n\nconst QUAD1_SQUARE = tf\n  .tensor2d([\n    [0, 0, 1],\n    [1, 0, 1],\n    [1, 1, 1],\n    [0, 1, 1],\n  ])\n  .transpose();\n\nexport default class BoxDecal extends Decal {\n  constructor({\n    width = 1,\n    height = 1,\n    position = ZERO_POS,\n    angle = 0,\n    centered = true,\n    solid = true,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.width = width;\n    this.height = height;\n    this.position = coercePositionVector(position);\n    this.angle = angle;\n    this.centered = !!centered;\n    this.solid = !!solid;\n    this.lineWidth = lineWidth;\n    this.color = color;\n    this._cornerPositions = tf.tidy(() =>\n      getRotationTranslationMatrix(-angle, this.position)\n        .matMul(getScaleMatrix(width, height))\n        .matMul(centered ? CENTERED_SQUARE : QUAD1_SQUARE),\n    );\n  }\n\n  dispose() {\n    this._cornerPositions.dispose();\n    this.position.dispose();\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return new BoxDecal({\n      width: this.width * scale,\n      height: this.height * scale,\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      centered: this.centered,\n      solid: this.solid,\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    let element;\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    const cornerPositions = tf.tidy(() =>\n      xformMatrix.matMul(this._cornerPositions).arraySync(),\n    );\n    if (this.solid) {\n      element = (\n        <rect\n          x={cornerPositions[0][3]}\n          y={cornerPositions[1][3]}\n          width={this.width * scale}\n          height={this.height * scale}\n          key={key}\n        />\n      );\n    } else {\n      const npoints = this._cornerPositions.shape[1];\n      const lines = [];\n      for (let i = 0; i < npoints; i++) {\n        const j = (i + 1) % npoints;\n        lines.push(\n          <line\n            className=\"plot__line\"\n            x1={cornerPositions[0][i]}\n            y1={cornerPositions[1][i]}\n            x2={cornerPositions[0][j]}\n            y2={cornerPositions[1][j]}\n            strokeWidth={this.lineWidth * scale}\n            stroke={this.color}\n            key={i}\n          />,\n        );\n      }\n      element = <g key={key}>{lines}</g>;\n    }\n    return element;\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class CircleDecal extends Decal {\n  constructor({ position = ZERO_POS, radius = 1, color = 'black' } = {}) {\n    super();\n    this.position = coercePositionVector(position);\n    this.radius = radius;\n    this.color = color;\n  }\n\n  dispose() {\n    this.position.dispose();\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return CircleDecal({\n      position: xformMatrix.matMul(this.position),\n      radius: this.radius * scale,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const xformed = tf.tidy(() => xformMatrix.matMul(this.position).dataSync());\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <circle\n        className=\"plot__circle\"\n        cx={xformed[0]}\n        cy={xformed[1]}\n        r={this.radius * scale}\n        fill={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class LineDecal extends Decal {\n  constructor({\n    endPos = required('endPos'),\n    startPos = ZERO_POS,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.startPos = coercePositionVector(startPos);\n    this.endPos = coercePositionVector(endPos);\n    this.lineWidth = lineWidth;\n    this.color = color;\n  }\n\n  dispose() {\n    this.startPos.dispose();\n    this.endPos.dispose();\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return LineDecal({\n      endPos: xformMatrix.matMul(this.endPos),\n      startPos: xformMatrix.matMul(this.startPos),\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const startPos = tf.tidy(() => xformMatrix.matMul(this.startPos).dataSync());\n    const endPos = tf.tidy(() => xformMatrix.matMul(this.endPos).dataSync());\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <line\n        className=\"plot__line\"\n        x1={startPos[0]}\n        y1={startPos[1]}\n        x2={endPos[0]}\n        y2={endPos[1]}\n        strokeWidth={this.lineWidth * scale}\n        stroke={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { coerceStateTuple } from './utils';\nimport { generateRandomId } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n    typeName = null,\n  } = {}) {\n    this.id = id != null ? id : generateRandomId();\n    this.typeName = typeName || this.constructor.name;\n    this.position = coercePositionVector(position);\n    this.decals = decals;\n    this.weights = weights;\n    this.frames = frames;\n    this.resistance = resistance;\n    this.initialState = coerceStateTuple(initialState);\n  }\n\n  dispose() {\n    this.frames.forEach((frame) => frame.dispose());\n    this.weights.forEach((weight) => weight.dispose());\n    this.decals.forEach((decals) => decals.dispose());\n    this.position.dispose();\n  }\n\n  getLocalPosMatrix(q = required('q')) {\n    return tf.eye(3);\n  }\n\n  getLocalVelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getLocalAccelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const [q] = stateMap.has(this.id) ? stateMap.get(this.id) : ZERO_STATE;\n    xformMatrix = tf.tidy(() => xformMatrix.matMul(this.getLocalPosMatrix(q)));\n    const domElement = (\n      <g className=\"frame\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, {\n            key: 'frame' + index,\n          }),\n        )}\n      </g>\n    );\n    xformMatrix.dispose();\n    return domElement;\n  }\n\n  toJsonObj({ includeDecals = false } = {}) {\n    const obj = {\n      frames: this.frames.map((frame) =>\n        frame.toJsonObj({ includeDecals: includeDecals }),\n      ),\n      id: this.id,\n      initialState: this.initialState,\n      position: tf.tidy(() => [...this.position.dataSync().slice(0, -1)]),\n      resistance: this.resistance,\n      type: this.typeName,\n      weights: this.weights.map((weight) => weight.toJsonObj()),\n    };\n    if (includeDecals) {\n      obj.decals = this.decals.map((decal) => decal.toJsonObj());\n    }\n    return obj;\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class RotationalFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n  } = {}) {\n    super({\n      decals: decals,\n      frames: frames,\n      id: id,\n      initialState: initialState,\n      position: position,\n      resistance: resistance,\n      typeName: 'RotationalFrame',\n      weights: weights,\n    });\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new RotationalFrame({\n      position: xformMatrix.matMul(this.position),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getLocalPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [c, -s, position[0]],\n      [s, c, position[1]],\n      [0, 0, 1],\n    ]);\n  }\n\n  getLocalVelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-s, -c, 0],\n      [c, -s, 0],\n      [0, 0, 0],\n    ]);\n  }\n\n  getLocalAccelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-c, s, 0],\n      [-s, -c, 0],\n      [0, 0, 0],\n    ]);\n  }\n}\n","import { NotImplementedError } from './utils';\nimport { required } from './utils';\n\nexport class InvalidStateMapError extends Error {\n  constructor(message) {\n    super('Encountered invalid state map');\n    this.name = 'InvalidStateMapError';\n  }\n}\n\nexport function isValidStateMap(stateMap = required('stateMap')) {\n  return [...stateMap].every(([frameId, [q, qd]]) => !isNaN(q) && !isNaN(qd));\n}\n\nexport function checkStateMapValid(stateMap = required('stateMap')) {\n  if (!isValidStateMap(stateMap)) {\n    throw new InvalidStateMapError();\n  }\n}\n\nexport default class Solver {\n  constructor(scene = required('scene')) {\n    this.scene = scene;\n  }\n\n  dispose() {}\n\n  getStateMap() {\n    throw new NotImplementedError('abstract method');\n  }\n\n  setStateMap(stateMap = required('stateMap')) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  resetStateMap() {\n    this.setStateMap(this.scene.getInitialStateMap());\n  }\n\n  tick(\n    deltaTime = required('deltaTime'),\n    tickCount = 1,\n    externalForceMap = null,\n  ) {\n    throw new NotImplementedError('abstract method');\n  }\n}\n","import Solver from './Solver';\nimport { InvalidStateMapError } from './Solver';\nimport { required } from './utils';\n\nexport default class RsSolver extends Solver {\n  constructor(\n    scene = required('scene'),\n    rsWasmModule = required('rsWasmModule'),\n    { rungeKutta = true } = {},\n  ) {\n    super(scene);\n    this.stateBuffer = new Float64Array(this.scene.sortedFrames.length * 2);\n    this.extForceBuffer = new Float64Array(this.scene.sortedFrames.length);\n    this.resetStateMap();\n    console.log('[js] Creating solver context');\n    const sceneJson = JSON.stringify(scene.toJsonObj());\n    this.context = new rsWasmModule.SolverContext(sceneJson);\n    this.context.setRungeKutta(rungeKutta);\n    console.log('[js] Created solver context:', this.context);\n  }\n\n  dispose() {\n    console.log('[js] Disposing solver context');\n    this.context.dispose();\n    console.log('[js] Disposed solver context');\n    this.context = null;\n  }\n\n  getStateMap() {\n    return new Map(\n      this.scene.sortedFrames.map((frame, index) => [\n        frame.id,\n        [this.stateBuffer[index * 2], this.stateBuffer[index * 2 + 1]],\n      ]),\n    );\n  }\n\n  setStateMap(stateMap = required('stateMap')) {\n    this.stateBuffer.set(\n      this.scene.sortedFrames.flatMap(\n        (frame) => stateMap.get(frame.id) || [0, 0],\n      ),\n    );\n  }\n\n  tick(\n    deltaTime = required('deltaTime'),\n    tickCount = 1,\n    externalForceMap = null,\n  ) {\n    this.extForceBuffer.set(\n      this.scene.sortedFrames.map((frame) =>\n        externalForceMap ? externalForceMap.get(frame.id) || 0 : 0,\n      ),\n    );\n    this.context.tick(this.stateBuffer, deltaTime, tickCount, this.extForceBuffer);\n    for (let i = 0; i < this.stateBuffer.length; i++) {\n      if (isNaN(this.stateBuffer[i])) {\n        throw new InvalidStateMapError();\n      }\n    }\n  }\n}\n","export const defaultGetNodeParents = (x) => x.parents;\nexport const defaultGetNodeKey = (x) => x;\n\nexport function toposort(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {}\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const markedNodes = new Set();\n  const sortedNodes = [];\n  const sortedKeys = [];\n\n  function visit(node, child) {\n    const nodeKey = getNodeKey(node);\n    if (markedNodes.has(nodeKey)) {\n      throw new Error(`Graph is not a DAG; recursively encountered ${node}`);\n    }\n    if (!sortedKeys.includes(nodeKey)) {\n      const parents = getNodeParents(node);\n      if (parents) {\n        markedNodes.add(nodeKey);\n        parents.forEach((parent) => visit(parent, node));\n        markedNodes.delete(nodeKey);\n        sortedNodes.push(node);\n        sortedKeys.push(nodeKey);\n      }\n    }\n  }\n\n  [...nodes].forEach((node) => visit(node, null));\n  return sortedNodes;\n}\n\nexport function getChildMap(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {}\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const childMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parents = getNodeParents(node);\n    childMap.has(nodeKey) || childMap.set(nodeKey, new Set());\n    parents.forEach((parent) => {\n      const parentKey = getNodeKey(parent);\n      childMap.has(parentKey) || childMap.set(parentKey, new Set());\n      childMap.get(parentKey).add(node);\n    });\n  });\n  return childMap;\n}\n\nexport function transform(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n    visitEdge = undefined,\n  } = {}\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  visitNode = visitNode || ((node, parentValues) => null);\n  visitEdge = visitEdge || ((node, parentNode, parentValue) => parentValue);\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const nodeMap = new Map();\n  const edgeMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parentNodes = getNodeParents(node);\n    const parentEdgeValues = parentNodes.map((parentNode) => {\n      const parentNodeKey = getNodeKey(parentNode);\n      const edgeValue = visitEdge(node, parentNode, nodeMap.get(parentNodeKey));\n      edgeMap.set([parentNodeKey, nodeKey], edgeValue);\n      return edgeValue;\n    });\n    const nodeValue = visitNode(node, parentEdgeValues);\n    nodeMap.set(nodeKey, nodeValue);\n  });\n  return [nodeMap, edgeMap];\n}\n\nexport function transformNodes(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n  } = {}\n) {\n  const [nodeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitNode: visitNode,\n  });\n  return nodeMap;\n}\n\nexport function transformEdges(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitEdge = undefined,\n  } = {}\n) {\n  const [, edgeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitEdge: visitEdge,\n  });\n  return edgeMap;\n}\n","import * as daglet from './daglet';\nimport * as tf from './tfjs';\nimport React from 'react';\nimport { required } from './utils';\n\nexport const DEFAULT_GRAVITY = 10;\n\nexport default class Scene {\n  constructor({\n    decals = [],\n    frames = [],\n    springs = [],\n    constraints = [],\n    gravity = DEFAULT_GRAVITY,\n  } = {}) {\n    this.decals = decals;\n    this.frames = frames;\n    this.springs = springs;\n    this.constraints = constraints;\n    this.gravity = gravity;\n\n    const getFrameChildren = (frame) => frame.frames;\n    const getFrameId = (frame) => frame.id;\n    this.sortedFrames = daglet\n      .toposort(this.frames, {\n        getNodeParents: getFrameChildren,\n        getNodeKey: getFrameId,\n      })\n      .reverse();\n    this.frameMap = new Map(\n      this.sortedFrames.map((frame) => [frame.id, frame]),\n    );\n    const frameIdParentsMap = daglet.getChildMap(this.sortedFrames, {\n      getNodeParents: getFrameChildren,\n      getNodeKey: getFrameId,\n    });\n    if ([...frameIdParentsMap.values()].some((parents) => parents.size > 1)) {\n      throw new Error('Frames should only have one parent'); // TODO: use AssertionError?\n    }\n    this.frameIdParentMap = new Map(\n      [...frameIdParentsMap].map(([frameId, parents]) => [\n        frameId,\n        parents.size ? [...parents][0].id : null,\n      ]),\n    );\n    this.frameIdPathMap = daglet.transformNodes(this.sortedFrames, {\n      getNodeParents: (frame) => [...frameIdParentsMap.get(frame.id)],\n      getNodeKey: getFrameId,\n      visitNode: (frame, parentPaths) =>\n        parentPaths.length ? [...parentPaths[0], frame.id] : [frame.id],\n    });\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = tf.eye(3),\n    { key = undefined } = {},\n  ) {\n    return (\n      <g className=\"scene\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, { key: 'frame' + index }),\n        )}\n      </g>\n    );\n  }\n\n  getInitialStateMap({ randomize = false } = {}) {\n    let getInitialState;\n    if (randomize) {\n      const randPi = () => (Math.random() - 0.5) * Math.PI * 2; // TBD\n      getInitialState = (frame) => [randPi(), randPi()];\n    } else {\n      getInitialState = (frame) => frame.initialState;\n    }\n    return new Map(\n      this.sortedFrames.map((frame) => [frame.id, getInitialState(frame)]),\n    );\n  }\n\n  toJsonObj({includeDecals = false} = {}) {\n    const obj = {\n      frames: this.frames.map((frame) => frame.toJsonObj({includeDecals: includeDecals})),\n      gravity: this.gravity,\n    }\n    if (includeDecals) {\n      obj.decals = this.decals.map((decal) => decal.toJsonObj())\n    }\n    return obj;\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { getTranslationMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class TrackFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    angle = 0,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = undefined,\n  } = {}) {\n    super({\n      angle: angle,\n      decals: decals,\n      frames: frames,\n      id: id,\n      initialState: initialState,\n      position: position,\n      resistance: resistance,\n      typeName: 'TrackFrame',\n      weights: weights,\n    });\n    this.angle = angle;\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new TrackFrame({\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getLocalPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    return getTranslationMatrix([\n      position[0] + q * Math.cos(this.angle),\n      position[1] + q * Math.sin(this.angle),\n    ]);\n  }\n\n  getLocalVelMatrix(q = required('q')) {\n    return tf.tensor2d([\n      [0, 0, Math.cos(this.angle)],\n      [0, 0, Math.sin(this.angle)],\n      [0, 0, 0],\n    ]);\n  }\n\n  toJsonObj(options = {}) {\n    return { angle: this.angle, ...super.toJsonObj(options) };\n  }\n}\n","import * as tf from './tfjs';\nimport { coercePositionVector } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class Weight {\n  constructor(mass = 1, { position = ZERO_POS, drag = 0 } = {}) {\n    this.mass = mass;\n    this.position = coercePositionVector(position);\n    this.drag = drag;\n  }\n\n  dispose() {\n    this.position.dispose();\n  }\n\n  xform(xformMatrix) {\n    return new Weight({\n      mass: this.mass,\n      position: xformMatrix.matMul(this.position),\n      drag: this.drag,\n    });\n  }\n\n  toJsonObj() {\n    return {\n      mass: this.mass,\n      position: tf.tidy(() => [...this.position.dataSync().slice(0, 2)]),\n      drag: this.drag,\n    }\n  }\n}\n","import './App.css';\nimport 'normalize.css';\nimport * as tf from './tfjs';\nimport BoxDecal from './BoxDecal';\nimport CircleDecal from './CircleDecal';\nimport LineDecal from './LineDecal';\nimport producer from 'immer';\nimport React from 'react';\nimport RotationalFrame from './RotationalFrame';\nimport RsSolver from './RsSolver';\nimport Scene from './Scene';\nimport TrackFrame from './TrackFrame';\nimport Weight from './Weight';\nimport { getScaleMatrix } from './utils';\nimport { getTranslationMatrix } from './utils';\nimport { required } from './utils';\nimport { useEffect } from 'react';\nimport { useRef } from 'react';\nimport { useState } from 'react';\nimport { InvalidStateMapError } from './Solver';\n\nconst poiMass = 60;\nconst poiDrag = 20;\nconst ropeSegmentLength = 1.6;\nconst ropeSegmentDrag = 8;\nconst ropeSegmentMass = 1;\nconst ropeSegmentResistance = 10;\nconst ropeSegmentCount = 5;\nconst cartMass = 250;\nconst maxCartForce = 8500;\nconst cartResistance = 5;\n\nconst initialScale = 12;\nconst MIN_ANIMATION_FPS = 5;\nconst TARGET_ANIMATION_FPS = 60;\nconst TIME_SCALE = 1.5;\nconst TARGET_PHYSICS_FPS = 400 * TIME_SCALE;\n\nconst stickLength = 8;\nconst segments = [0, 1].map((ropeNum) =>\n  Array(ropeSegmentCount)\n    .fill()\n    .map((x, index) => index)\n    .reduce((childSegment, index) => {\n      const length = ropeSegmentLength * (1 + ropeNum * 0.02);\n      const first = index === 0;\n      const last = index === ropeSegmentCount - 1;\n      const radius = first ? 1 : 0.3 / 2;\n      const mass = first ? poiMass : ropeSegmentMass;\n      const drag = first ? poiDrag : ropeSegmentDrag;\n      const weights = [\n        new Weight(mass, {\n          position: [length, 0],\n          drag: drag,\n        }),\n      ];\n      const decals = [\n        new LineDecal({\n          endPos: [length * 1.03, 0],\n          lineWidth: 0.3,\n        }),\n      ];\n      if (first || true) {\n        decals.push(\n          new CircleDecal({\n            position: [length, 0],\n            radius: radius,\n          }),\n        );\n      }\n      return new RotationalFrame({\n        id: `segment${ropeNum}-${index}`,\n        initialState: last ? [Math.PI * 0.3 * (2 * ropeNum + 1), 0] : [0, 0],\n        decals: decals,\n        frames: childSegment ? [childSegment] : [],\n        position: [last ? stickLength : length, 0],\n        weights: weights,\n        resistance: ropeSegmentResistance,\n      });\n    }, null),\n);\n\nconst stick = new RotationalFrame({\n  id: 'stick',\n  decals: [\n    new LineDecal({\n      endPos: [stickLength * 1.02, 0],\n      lineWidth: 0.45,\n    }),\n    new CircleDecal({ position: [stickLength, 0], radius: 0.5 }),\n  ],\n  weights: [new Weight(40, { position: [stickLength, 0], drag: 15 })],\n  frames: segments,\n});\n\nconst cart = new TrackFrame({\n  id: 'cart',\n  decals: [\n    new BoxDecal({\n      width: 3,\n      height: 3 / 1.618,\n      //color: 'blue',\n      lineWidth: 0.2,\n    }),\n  ],\n  frames: [stick],\n  initialState: [0, 0],\n  weights: [new Weight(cartMass)],\n  resistance: cartResistance,\n});\n\nconst scene = new Scene({\n  frames: [cart],\n  decals: [\n    new LineDecal({\n      startPos: [-300, 0],\n      endPos: [300, 0],\n      color: 'gray',\n      lineWidth: 0.1,\n    }),\n  ],\n});\n\nfunction useKeyboard(callback = null) {\n  const [pressedKeys, setPressedKeys] = useState(new Set());\n  const callbackRef = useRef();\n  callbackRef.current = callback;\n\n  useEffect(() => {\n    function handleKeyDown({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (!pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.add(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: true,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n    function handleKeyUp({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.delete(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: false,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n\n  return pressedKeys;\n}\n\nfunction useMouse(elementRef = required('elementRef')) {\n  const [startLocation, setStartLocation] = useState(null);\n  const [endLocation, setEndLocation] = useState(null);\n\n  useEffect(() => {\n    function handleMouseDown(event) {\n      console.log('start', event);\n      setStartLocation([event.x, event.y]);\n      setEndLocation(null);\n    }\n    function handleMouseMove(event) {\n      setEndLocation([event.x, event.y]);\n    }\n    function handleMouseUp(event) {\n      console.log('end');\n      setStartLocation(null);\n      setEndLocation(null);\n    }\n    const element = elementRef.current;\n    element.addEventListener('mousedown', handleMouseDown);\n    element.addEventListener('mousemove', handleMouseMove);\n    element.addEventListener('mouseup', handleMouseUp);\n    return () => {\n      element.removeEventListener('mousedown', handleMouseDown);\n      element.removeEventListener('mousemove', handleMouseMove);\n      element.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [elementRef]);\n\n  const locationDelta =\n    startLocation && endLocation\n      ? [endLocation[0] - startLocation[0], endLocation[1] - startLocation[1]]\n      : null;\n  return locationDelta;\n}\n\nfunction useTouch(elementRef = required('elementRef')) {\n  const [startLocation, setStartLocation] = useState(null);\n  const [endLocation, setEndLocation] = useState(null);\n\n  useEffect(() => {\n    function handleTouchStart(event) {\n      if (event.which === 0 && event.touches.length > 0) {\n        setStartLocation([event.touches[0].clientX, event.touches[0].clientY]);\n        setEndLocation(null);\n      }\n      event.preventDefault();\n    }\n    function handleTouchMove(event) {\n      if (event.which === 0 && event.touches.length > 0) {\n        setEndLocation([event.touches[0].clientX, event.touches[0].clientY]);\n      }\n      event.preventDefault();\n    }\n    function handleTouchEnd(event) {\n      if (event.which === 0) {\n        setStartLocation(null);\n        setEndLocation(null);\n      }\n      event.preventDefault();\n    }\n    const element = elementRef.current;\n    element.addEventListener('touchstart', handleTouchStart);\n    element.addEventListener('touchmove', handleTouchMove);\n    element.addEventListener('touchend', handleTouchEnd);\n    return () => {\n      element.removeEventListener('touchstart', handleTouchStart);\n      element.removeEventListener('touchmove', handleTouchMove);\n      element.removeEventListener('touchend', handleTouchEnd);\n    };\n  }, [elementRef]);\n\n  const locationDelta =\n    startLocation && endLocation\n      ? [endLocation[0] - startLocation[0], endLocation[1] - startLocation[1]]\n      : null;\n  return locationDelta;\n}\n\nconst useAnimationFrame = (\n  callback = required('callback'),\n  { fps = TARGET_ANIMATION_FPS } = {},\n) => {\n  const state = React.useRef({ prevTime: 0 });\n  const requestRef = React.useRef();\n  const timerRef = React.useRef();\n  state.current.callback = callback;\n\n  React.useEffect(() => {\n    function animate(time = required('time')) {\n      const deltaTime = (time - state.current.prevTime) / 1000;\n      const delay = Math.max(1000 / fps - deltaTime, 0);\n      state.current.callback(deltaTime);\n      state.current.prevTime = time;\n      timerRef.current = setTimeout(() => {\n        requestRef.current = requestAnimationFrame(animate);\n      }, delay);\n    }\n\n    requestRef.current = requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n      timerRef.current && clearTimeout(timerRef.current);\n    };\n  }, [fps]);\n};\n\nfunction handleViewControls({\n  deltaTime = required('deltaTime'),\n  pressedKeys = required('pressedKeys'),\n  scale = required('scale'),\n  setScale = required('setScale'),\n  setTranslation = required('setTranslation'),\n  translation = required('translation'),\n} = {}) {\n  Object.entries({\n    Minus: () => setScale(scale * Math.exp(-deltaTime)),\n    Equal: () => setScale(scale * Math.exp(deltaTime)),\n    KeyH: () => setTranslation(([x, y]) => [x + deltaTime * 20, y]),\n    KeyK: () => setTranslation(([x, y]) => [x - deltaTime * 20, y]),\n    KeyU: () => setTranslation(([x, y]) => [x, y - deltaTime * 20]),\n    KeyJ: () => setTranslation(([x, y]) => [x, y + deltaTime * 20]),\n  }).forEach(([keyName, func]) => pressedKeys.has(keyName) && func());\n}\n\nfunction getExternalForceMap(\n  pressedKeys = required('pressedKeys'),\n  clickLocationDelta = required('clickLocationDelta'),\n  touchLocationDelta = required('touchLocationDelta'),\n  deltaTime = required('deltaTime'),\n) {\n  let cartForce = 0;\n  if (pressedKeys.has('KeyA') || pressedKeys.has('ArrowLeft')) {\n    cartForce -= maxCartForce;\n  } else if (pressedKeys.has('KeyD') || pressedKeys.has('ArrowRight')) {\n    cartForce += maxCartForce;\n  }\n  if (clickLocationDelta) {\n    cartForce += (clickLocationDelta[0] / 200) * maxCartForce;\n  }\n  if (touchLocationDelta) {\n    cartForce += (touchLocationDelta[0] / 60) * maxCartForce;\n  }\n  if (Math.abs(cartForce) > maxCartForce) {\n    cartForce = Math.sign(cartForce) * maxCartForce;\n  }\n  return new Map([[cart.id, cartForce]]);\n}\n\nfunction simulate(\n  solver = required('solver'),\n  externalForceMap = required('externalForceMap'),\n  animationDeltaTime = required('animationDeltaTime'),\n) {\n  const deltaTime = TIME_SCALE / TARGET_PHYSICS_FPS;\n  let tickCount = Math.floor(\n    Math.min(animationDeltaTime / deltaTime, TARGET_PHYSICS_FPS),\n  );\n  if (animationDeltaTime > 1 / MIN_ANIMATION_FPS) {\n    tickCount = Math.floor(\n      Math.min(tickCount, TARGET_PHYSICS_FPS / MIN_ANIMATION_FPS),\n    );\n    console.warn(\n      `Falling below minimum desired animation FPS; limiting simulation to ${tickCount} ticks`,\n    );\n  }\n  try {\n    solver.tick(\n      deltaTime,\n      Math.min(tickCount, TARGET_PHYSICS_FPS),\n      externalForceMap,\n    );\n  } catch (error) {\n    if (error instanceof InvalidStateMapError) {\n      console.warn(\n        'Encountered invalid state map; resetting to initial state...',\n      );\n      solver.resetStateMap();\n    } else {\n      throw error;\n    }\n  }\n  return solver.getStateMap();\n}\n\nfunction getViewXformMatrix(translation, scale) {\n  return tf.tidy(() =>\n    getTranslationMatrix([300, 300])\n      .matMul(getScaleMatrix(scale, -scale))\n      .matMul(getTranslationMatrix(translation)),\n  );\n}\n\nfunction createSolver(\n  scene = required('scene'),\n  rsWasmModule = required('rsWasmModule'),\n) {\n  //console.log('[js] Creating solver');\n  //const solver = new JsSolver(scene, { rungeKutta: false });\n  const solver = new RsSolver(scene, rsWasmModule, { rungeKutta: true });\n  window.solver = solver; // (for debugging)\n  //console.log('[js] Solver:', solver);\n  return solver;\n}\n\nfunction App({ rsWasmModule }) {\n  const [paused, setPaused] = useState(false);\n  const [translation, setTranslation] = useState([0, 0]);\n  const [scale, setScale] = useState(initialScale);\n  const svgRef = React.useRef();\n  const pressedKeys = useKeyboard();\n  const clickLocationDelta = useMouse(svgRef);\n  const touchLocationDelta = useTouch(svgRef);\n  const [stateMap, setStateMap] = useState(scene.getInitialStateMap());\n  const viewXformMatrix = getViewXformMatrix(translation, scale);\n  const sceneDomElement = scene.getDomElement(stateMap, viewXformMatrix);\n  viewXformMatrix.dispose();\n  const solver = useRef(null);\n\n  useEffect(() => {\n    solver.current = createSolver(scene, rsWasmModule);\n  }, [rsWasmModule]);\n\n  useAnimationFrame((deltaTime) => {\n    handleViewControls({\n      deltaTime,\n      pressedKeys,\n      scale,\n      setScale,\n      setTranslation,\n      translation,\n    });\n    if (!paused) {\n      const externalForceMap = getExternalForceMap(\n        pressedKeys,\n        clickLocationDelta,\n        touchLocationDelta,\n        deltaTime,\n      );\n      const newStateMap = simulate(solver.current, externalForceMap, deltaTime);\n      setStateMap(newStateMap);\n    }\n  });\n\n  const togglePaused = () => {\n    setPaused(!paused);\n  };\n\n  return (\n    <div className=\"app__main\">\n      <div className=\"plot\">\n        <h2 className=\"plot__title\">Double CartPoi</h2>\n        {\n          //<p>Number of tensors: {tf.memory().numTensors}</p>\n        }\n        {\n          //<p>Keys: {[...pressedKeys].join(', ')}</p>\n        }\n        {\n          //<p>Scale: {scale.toFixed(2)}</p>\n        }\n        <div className=\"plot__main\">\n          <svg className=\"plot__svg\" ref={svgRef}>\n            {sceneDomElement}\n          </svg>\n        </div>\n        <button onClick={togglePaused}>{paused ? 'Unpause' : 'Pause'}</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import './index.css';\nimport * as immer from 'immer';\nimport * as serviceWorker from './serviceWorker';\nimport * as tf from '@tensorflow/tfjs';\nimport * as tfWasm from '@tensorflow/tfjs-backend-wasm';\nimport App from './App';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimmer.enableMapSet();\n\nwindow.tf = tf; // (for debugging)\n\nfunction initTfCpuBackend() {\n  tf.setBackend('cpu');\n}\n\nfunction initTfWebGLBackend() {\n  tf.env().set('WEBGL_CPU_FORWARD', false);\n  tf.setBackend('webgl');\n}\n\nasync function initTfWasmBackend() {\n  tfWasm.setWasmPaths('/');\n  await tf.setBackend('wasm');\n}\n\nasync function initRsWasmModule() {\n  const rsWasmModule = await import('physm-rs');\n  window.wasm = rsWasmModule; // (for debugging)\n  return rsWasmModule;\n}\n\nasync function init() {\n  tf.enableProdMode();\n  initTfCpuBackend();\n  //initTfWebGLBackend();\n  //await initTfWasmBackend();\n  return await initRsWasmModule();\n}\n\nfunction main(rsWasmModule) {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App rsWasmModule={rsWasmModule} />\n    </React.StrictMode>,\n    document.getElementById('root'),\n  );\n}\n\ninit().then((rsWasmModule) => main(rsWasmModule));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}