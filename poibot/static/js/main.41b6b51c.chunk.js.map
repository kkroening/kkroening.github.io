{"version":3,"sources":["serviceWorker.js","utils.js","Decal.js","BoxDecal.js","CircleDecal.js","LineDecal.js","Frame.js","RotationalFrame.js","daglet.js","Scene.js","Solver.js","TrackFrame.js","Weight.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","ZERO_POS","tf","ZERO_STATE","MissingArgumentError","Error","NotImplementedError","DimensionError","SingularMatrixError","required","name","coercePositionVector","position","data","dataSync","length","reshape","Array","TypeError","coerceStateTuple","state","getScaleMatrix","x","y","undefined","getTranslationMatrix","offset","getRotationTranslationMatrix","angle","c","Math","cos","s","sin","checkXformMatrixShape","mat","toString","shape","getXformMatrixDeterminant","getXformMatrixScaleFactor","sqrt","abs","getXformMatrixRotationAngle","atan2","invertXformMatrix","det","solveLinearSystem","aMat","bVec","asTensor","JSON","stringify","n","qr","qMat","rMat","cVec","transpose","matMul","rArray","arraySync","xArray","i","sum","j","generateRandomId","random","substr","Decal","key","CENTERED_SQUARE","QUAD1_SQUARE","BoxDecal","width","height","centered","solid","lineWidth","color","_cornerPositions","xformMatrix","scale","this","element","cornerPositions","npoints","lines","push","className","x1","y1","x2","y2","strokeWidth","stroke","CircleDecal","radius","xformed","cx","cy","r","fill","LineDecal","endPos","startPos","Frame","decals","weights","frames","resistance","initialState","id","stateMap","has","get","q","getPosMatrix","map","decal","index","getDomElement","frame","RotationalFrame","defaultGetNodeParents","parents","defaultGetNodeKey","toposort","nodes","getNodeParents","getNodeKey","markedNodes","Set","sortedNodes","sortedKeys","unvisitedNodes","visit","node","child","nodeKey","includes","add","forEach","parent","delete","pop","getChildMap","childMap","Map","set","parentKey","transform","visitNode","visitEdge","parentValues","parentNode","parentValue","nodeMap","edgeMap","parentEdgeValues","parentNodeKey","edgeValue","nodeValue","transformNodes","Scene","springs","constraints","gravity","getFrameChildren","getFrameId","sortedFrames","daglet","reverse","frameMap","frameIdParentsMap","values","some","size","frameIdParentMap","frameId","frameIdPathMap","parentPaths","getInitialState","randomize","randPi","PI","Solver","scene","qs","qds","posMatMap","parentId","invPosMatMap","getVelMatrix","getAccelMatrix","velMatMap","velSumMatMap","qd","mul","accelMatMap","accelSumMatMap","parentAccelSumMat","parentVelSumMat","velMat","weight","descendentFrame","ancestorFrame","indexOf","frame1","frame2","_isFrameDescendent","filter","rowIndex","colIndex","weightPosMap","velMat1","velMat2","baseFrame","_getDescendentFrame","descendentFrames","_getDescendentFrames","result","frame3","pos","mass","numFrames","array","columns","_getCoefficientMatrixEntry","externalForceMap","baseVelMat","childFrame","childVelSumMat","childAccelSumMat","weightIndex","weightPos","weightBaseVel","weightChildVelSum","weightChildAccelSum","kineticForce","gravityForce","dragForce","drag","resistanceForce","externalForce","_getForceVectorEntry","_getPosMatMap","_getInvPosMatMap","_getVelMatMap","_getAccelMatMap","_getVelSumMatMap","_getAccelSumMatMap","_getWeightPosMap","_getCoefficientMatrix","_getForceVector","_getSystemOfEquations","qddArray","deltaTime","newStateMap","qdd","newQ","newQd","_solve","_applyDeltas","rungeKutta","doTick","_tickRungeKutta","_tickSimple","bind","TrackFrame","Weight","pendulum2","pendulum1","cart","solver","App","useState","translationX","translationY","setTranslation","setScale","pressedKeys","callback","setPressedKeys","callbackRef","useRef","current","useEffect","handleKeyDown","code","keyCode","producer","draft","keyName","keyId","pressed","handleKeyUp","addEventListener","removeEventListener","useKeyboard","getInitialStateMap","setStateMap","params","fps","React","prevTime","requestRef","timerRef","requestAnimationFrame","animate","time","setTimeout","cancelAnimationFrame","clearTimeout","useAnimationFrame","cartForce","Object","entries","KeyA","KeyD","Minus","exp","Equal","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","func","tick","every","isNaN","isValidStateMap","console","warn","immer","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.41b6b51c.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import * as tf from './tfjs';\n\nexport const ZERO_POS = tf.tensor2d([[0], [0], [1]]);\nexport const ZERO_VEL = tf.tensor2d([[0], [0], [0]]);\nexport const ZERO_STATE = [0, 0];\nexport const DEFAULT_TOLERANCE = 1e-6;\n\nexport class MissingArgumentError extends Error {}\nexport class NotImplementedError extends Error {}\nexport class DimensionError extends Error {}\nexport class SingularMatrixError extends Error {}\n\nexport function required(name) {\n  throw new MissingArgumentError(`Missing required function argument: ${name}`);\n}\n\nexport function coercePositionVector(position = required('position')) {\n  /**\n   * Convert the input argument into a tensor of shape `[3, 1]`, corresponding\n   * to an affine position vector where the final component is guaranteed to\n   * have a value of 1.\n   * @param {(number|number[]|tf.Tensor)} position\n   * @returns {tf.Tensor}\n   */\n  if (position instanceof tf.Tensor) {\n    const data = position.dataSync();\n    if (data.length < 2 || data.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` tensor to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor1d([data[0], data[1], 1]).reshape([3, 1]);\n  } else if (position instanceof Array) {\n    if (position.length < 2 || position.length > 3) {\n      throw new DimensionError(\n        `Expected \\`position\\` array to have 2 or 3 elements; got ${position}`,\n      );\n    }\n    position = tf.tensor2d([[position[0]], [position[1]], [1]]);\n  } else if (typeof position == 'number') {\n    position = tf.tensor2d([[position], [0], [1]]);\n  } else {\n    throw new TypeError(\n      `Expected \\`position\\` to be a number, array, or tf.Tensor instance; got ${position}`,\n    );\n  }\n  return position;\n}\n\nexport function coerceStateTuple(state = required('state')) {\n  /**\n   * Convert the input into a pair of numbers as a `[position, velocity]`\n   * list/tuple.\n   * @param {(number|number[])} state\n   * @returns {(number[])}\n   */\n  if (state == null) {\n    state = ZERO_STATE;\n  } else if (state === ZERO_STATE) {\n  } else if (typeof state == 'number') {\n    state = [state, 0];\n  } else if (state instanceof Array) {\n    if (state.length === 0 || state.length > 2) {\n      throw new DimensionError(\n        `Expected \\`state\\` tuple/array to have 1 or 2 elements; got ${state}`,\n      );\n    }\n    state = [state[0], state.length > 1 ? state[1] : 0];\n  } else {\n    throw new TypeError(\n      `Expected \\`state\\` to be tf.Tensor instance; got ${state}`,\n    );\n  }\n  return state;\n}\n\nexport function getScaleMatrix(x = required('x'), y = undefined) {\n  if (y == null) {\n    y = x;\n  }\n  return tf.tensor2d([\n    [x, 0, 0],\n    [0, y, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getRotationMatrix(angle = required('angle')) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, 0],\n    [s, c, 0],\n    [0, 0, 1],\n  ]);\n}\n\nexport function getTranslationMatrix(offset = required('offset')) {\n  offset = coercePositionVector(offset).dataSync();\n  return tf.tensor2d([\n    [1, 0, offset[0]],\n    [0, 1, offset[1]],\n    [0, 0, offset[2]],\n  ]);\n}\n\nexport function getRotationTranslationMatrix(\n  angle = required('angle'),\n  offset = required('offset'),\n) {\n  offset = coercePositionVector(offset).dataSync();\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  return tf.tensor2d([\n    [c, -s, offset[0]],\n    [s, c, offset[1]],\n    [0, 0, offset[2]],\n  ]);\n}\n\nexport function checkXformMatrixShape(mat = required('mat')) {\n  if (!(mat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected transformation matrix \\`mat\\` to be tf.Tensor instance; got ${mat.toString()}`,\n    );\n  }\n  if (mat.shape.length !== 2 || mat.shape[0] !== 3 || mat.shape[1] !== 3) {\n    throw new DimensionError(\n      `Expected transformation matrix \\`mat\\` to have shape [3, 3]; got ${mat.toString()}`,\n    );\n  }\n}\n\nexport function getXformMatrixDeterminant(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return data[0] * data[4] - data[1] * data[3];\n}\n\nexport function getXformMatrixScaleFactor(mat = required('mat')) {\n  return Math.sqrt(Math.abs(getXformMatrixDeterminant(mat)));\n}\n\nexport function getXformMatrixRotationAngle(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return Math.atan2(data[1], -data[0]);\n}\n\nexport function getXformMatrixTranslation(mat = required('mat')) {\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  return tf.tensor2d([[data[2], data[5], data[8]]]);\n}\n\nexport function invertXformMatrix(mat = required('mat')) {\n  /**\n   * Invert a 3x3 transformation matrix.\n   */\n  checkXformMatrixShape(mat);\n  const data = mat.dataSync();\n  const det =\n    data[0] * data[4] * data[8] +\n    data[1] * data[5] * data[6] +\n    data[2] * data[3] * data[7] -\n    data[0] * data[5] * data[7] -\n    data[1] * data[3] * data[8] -\n    data[2] * data[4] * data[6];\n  return tf.tensor2d([\n    [\n      +(data[4] * data[8] - data[5] * data[7]) / det,\n      -(data[1] * data[8] - data[2] * data[7]) / det,\n      +(data[1] * data[5] - data[2] * data[4]) / det,\n    ],\n    [\n      -(data[3] * data[8] - data[5] * data[6]) / det,\n      +(data[0] * data[8] - data[2] * data[6]) / det,\n      -(data[0] * data[5] - data[2] * data[3]) / det,\n    ],\n    [\n      +(data[3] * data[7] - data[4] * data[6]) / det,\n      -(data[0] * data[7] - data[1] * data[6]) / det,\n      +(data[0] * data[4] - data[1] * data[3]) / det,\n    ],\n  ]);\n}\n\nexport function solveLinearSystem(\n  aMat = required('aMat'),\n  bVec = required('bVec'),\n  { asTensor = true } = {},\n) {\n  /**\n   * Solve a linear system of equations using QR decomposition and\n   * back-substitution.\n   */\n  if (!(aMat instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`aMat\\` to be tf.Tensor instance; got ${aMat}`,\n    );\n  } else if (!(bVec instanceof tf.Tensor)) {\n    throw new TypeError(\n      `Expected \\`bVec\\` to be tf.Tensor instance; got ${bVec}`,\n    );\n  } else if (aMat.shape.length !== 2 || aMat.shape[0] !== aMat.shape[1]) {\n    throw new DimensionError(\n      'Expected `aMat` to be a square matrix (2D tensor); ' +\n        `got tensor with shape ${JSON.stringify(aMat.shape)}`,\n    );\n  } else if (bVec.shape.length !== 2 || bVec.shape[1] !== 1) {\n    throw new DimensionError(\n      'Expected `bVec` to be a column vector (2D tensor with one column); ' +\n        `got tensor with shape ${JSON.stringify(bVec.shape)}`,\n    );\n  } else if (aMat.shape[1] !== bVec.shape[0]) {\n    throw new DimensionError(\n      'Expected `aMat` and `bVec` to have compatible shapes; ' +\n        `got aMat shape ${JSON.stringify(aMat.shape)} ` +\n        `and bVec shape ${JSON.stringify(bVec.shape)}`,\n    );\n  }\n  const n = bVec.shape[0];\n  const [qMat, rMat] = tf.linalg.qr(aMat);\n  const cVec = qMat.transpose().matMul(bVec).dataSync();\n  const rArray = rMat.arraySync();\n  const xArray = Array(n);\n  for (let i = n - 1; i >= 0; i--) {\n    if (Math.abs(rArray[i][i]) < DEFAULT_TOLERANCE) {\n      throw new SingularMatrixError(`Singular matrix: ${aMat.toString()}`);\n    }\n    let sum = 0;\n    for (let j = i + 1; j < n; j++) {\n      sum += rArray[i][j] * xArray[j];\n    }\n    xArray[i] = (cVec[i] - sum) / rArray[i][i];\n  }\n  return asTensor ? tf.tensor1d(xArray).reshape([n, 1]) : xArray;\n}\n\nexport function areTensorsEqual(\n  t1 = required('t1'),\n  t2 = required('t2'),\n  { tolerance = DEFAULT_TOLERANCE } = {},\n) {\n  return !!tf.all(t1.sub(t2).abs().less(tolerance)).dataSync()[0];\n}\n\nexport function generateRandomId() {\n  /** See `https://gist.github.com/gordonbrander/2230317`.\n   */\n  return Math.random().toString(36).substr(2, 9);\n}\n","import { NotImplementedError } from './utils';\nimport { required } from './utils';\n\nexport default class Decal {\n  xform(xformMatrix = required('xformMatrix')) {\n    throw new NotImplementedError('abstract method');\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    throw new NotImplementedError('abstract method');\n  }\n}\n","import * as tf from './tfjs';\nimport Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getRotationTranslationMatrix } from './utils';\nimport { getScaleMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nconst CENTERED_SQUARE = tf\n  .tensor2d([\n    [-0.5, -0.5, 1],\n    [0.5, -0.5, 1],\n    [0.5, 0.5, 1],\n    [-0.5, 0.5, 1],\n  ])\n  .transpose();\n\nconst QUAD1_SQUARE = tf\n  .tensor2d([\n    [0, 0, 1],\n    [1, 0, 1],\n    [1, 1, 1],\n    [0, 1, 1],\n  ])\n  .transpose();\n\nexport default class BoxDecal extends Decal {\n  constructor({\n    width = 1,\n    height = 1,\n    position = ZERO_POS,\n    angle = 0,\n    centered = true,\n    solid = true,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.width = width;\n    this.height = height;\n    this.position = coercePositionVector(position);\n    this.angle = angle;\n    this.centered = !!centered;\n    this.solid = !!solid;\n    this.lineWidth = lineWidth;\n    this.color = color;\n    this._cornerPositions = getRotationTranslationMatrix(-angle, this.position)\n      .matMul(getScaleMatrix(width, height))\n      .matMul(centered ? CENTERED_SQUARE : QUAD1_SQUARE);\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return new BoxDecal({\n      width: this.width * scale,\n      height: this.height * scale,\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      centered: this.centered,\n      solid: this.solid,\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    let element;\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    const cornerPositions = xformMatrix.matMul(this._cornerPositions).arraySync();\n    if (this.solid) {\n      const position = xformMatrix.matMul(this.position).dataSync();\n      element = (\n        <rect\n          x={cornerPositions[0][3]}\n          y={cornerPositions[1][3]}\n          width={this.width * scale}\n          height={this.height * scale}\n          key={key}\n        />\n      );\n    } else {\n      const npoints = this._cornerPositions.shape[1];\n      const lines = [];\n      for (let i = 0; i < npoints; i++) {\n        const j = (i + 1) % npoints;\n        lines.push(\n          <line\n            className=\"plot__line\"\n            x1={cornerPositions[0][i]}\n            y1={cornerPositions[1][i]}\n            x2={cornerPositions[0][j]}\n            y2={cornerPositions[1][j]}\n            strokeWidth={this.lineWidth * scale}\n            stroke={this.color}\n            key={i}\n          />,\n        );\n      }\n      element = <g key={key}>{lines}</g>;\n    }\n    return element;\n  }\n}\n","import Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class CircleDecal extends Decal {\n  constructor({ position = ZERO_POS, radius = 1, color = 'black' } = {}) {\n    super();\n    this.position = coercePositionVector(position);\n    this.radius = radius;\n    this.color = color;\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return CircleDecal({\n      position: xformMatrix.matMul(this.position),\n      radius: this.radius * scale,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const xformed = xformMatrix.matMul(this.position).dataSync();\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <circle\n        className=\"plot__circle\"\n        cx={xformed[0]}\n        cy={xformed[1]}\n        r={this.radius * scale}\n        fill={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import Decal from './Decal';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { getXformMatrixScaleFactor } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class LineDecal extends Decal {\n  constructor({\n    endPos = required('endPos'),\n    startPos = ZERO_POS,\n    lineWidth = 1,\n    color = 'black',\n  } = {}) {\n    super();\n    this.startPos = coercePositionVector(startPos);\n    this.endPos = coercePositionVector(endPos);\n    this.lineWidth = lineWidth;\n    this.color = color;\n  }\n\n  xform(xformMatrix = required('xformMatrix')) {\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return LineDecal({\n      endPos: xformMatrix.matMul(this.endPos),\n      startPos: xformMatrix.matMul(this.startPos),\n      lineWidth: this.lineWidth * scale,\n      color: this.color,\n    });\n  }\n\n  getDomElement(\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const startPos = xformMatrix.matMul(this.startPos).dataSync();\n    const endPos = xformMatrix.matMul(this.endPos).dataSync();\n    const scale = getXformMatrixScaleFactor(xformMatrix);\n    return (\n      <line\n        className=\"plot__line\"\n        x1={startPos[0]}\n        y1={startPos[1]}\n        x2={endPos[0]}\n        y2={endPos[1]}\n        strokeWidth={this.lineWidth * scale}\n        stroke={this.color}\n        key={key}\n      />\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport React from 'react';\nimport { coercePositionVector } from './utils';\nimport { coerceStateTuple } from './utils';\nimport { generateRandomId } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n  } = {}) {\n    this.id = id != null ? id : generateRandomId();\n    this.position = coercePositionVector(position);\n    this.decals = decals;\n    this.weights = weights;\n    this.frames = frames;\n    this.resistance = resistance;\n    this.initialState = coerceStateTuple(initialState);\n  }\n\n  getPosMatrix(q = required('q')) {\n    return tf.eye(3);\n  }\n\n  getVelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getAccelMatrix(q = required('q')) {\n    return tf.zeros([3, 3]);\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = required('xformMatrix'),\n    { key = undefined } = {},\n  ) {\n    const [q] = stateMap.has(this.id) ? stateMap.get(this.id) : ZERO_STATE;\n    xformMatrix = xformMatrix.matMul(this.getPosMatrix(q));\n    return (\n      <g className=\"frame\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, { key: 'frame' + index }),\n        )}\n      </g>\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class RotationalFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = null,\n  } = {}) {\n    super({\n      position: position,\n      decals: decals,\n      weights: weights,\n      frames: frames,\n      resistance: resistance,\n      initialState: initialState,\n      id: id,\n    });\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new RotationalFrame({\n      position: xformMatrix.matMul(this.position),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [c, -s, position[0]],\n      [s, c, position[1]],\n      [0, 0, 1],\n    ]);\n  }\n\n  getVelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-s, -c, 0],\n      [c, -s, 0],\n      [0, 0, 0],\n    ]);\n  }\n\n  getAccelMatrix(q = required('q')) {\n    const c = Math.cos(q);\n    const s = Math.sin(q);\n    return tf.tensor2d([\n      [-c, s, 0],\n      [-s, -c, 0],\n      [0, 0, 0],\n    ]);\n  }\n}\n","export const defaultGetNodeParents = (x) => x.parents;\nexport const defaultGetNodeKey = (x) => x;\n\nexport function toposort(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {},\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const markedNodes = new Set();\n  const sortedNodes = [];\n  const sortedKeys = [];\n  const unvisitedNodes = [...nodes];\n\n  function visit(node, child) {\n    const nodeKey = getNodeKey(node);\n    if (markedNodes.has(nodeKey)) {\n      throw new Error(`Graph is not a DAG; recursively encountered ${node}`);\n    }\n    if (!sortedKeys.includes(nodeKey)) {\n      const parents = getNodeParents(node);\n      if (parents) {\n        markedNodes.add(nodeKey);\n        parents.forEach((parent) => visit(parent, node));\n        markedNodes.delete(nodeKey);\n        sortedNodes.push(node);\n        sortedKeys.push(nodeKey);\n      }\n    }\n  }\n\n  while (unvisitedNodes.length) {\n    const node = unvisitedNodes.pop();\n    visit(node, null);\n  }\n  return sortedNodes;\n}\n\nexport function getChildMap(\n  nodes,\n  { getNodeParents = undefined, getNodeKey = undefined } = {},\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const childMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parents = getNodeParents(node);\n    childMap.has(nodeKey) || childMap.set(nodeKey, new Set());\n    parents.forEach((parent) => {\n      const parentKey = getNodeKey(parent);\n      childMap.has(parentKey) || childMap.set(parentKey, new Set());\n      childMap.get(parentKey).add(node);\n    });\n  });\n  return childMap;\n}\n\nexport function transform(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n    visitEdge = undefined,\n  } = {},\n) {\n  getNodeParents = getNodeParents || defaultGetNodeParents;\n  getNodeKey = getNodeKey || defaultGetNodeKey;\n  visitNode = visitNode || ((node, parentValues) => null);\n  visitEdge = visitEdge || ((node, parentNode, parentValue) => parentValue);\n  const sortedNodes = toposort(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n  });\n  const nodeMap = new Map();\n  const edgeMap = new Map();\n  sortedNodes.forEach((node) => {\n    const nodeKey = getNodeKey(node);\n    const parentNodes = getNodeParents(node);\n    const parentEdgeValues = parentNodes.map((parentNode) => {\n      const parentNodeKey = getNodeKey(parentNode);\n      const edgeValue = visitEdge(node, parentNode, nodeMap.get(parentNodeKey));\n      edgeMap.set([parentNodeKey, nodeKey], edgeValue);\n      return edgeValue;\n    });\n    const nodeValue = visitNode(node, parentEdgeValues);\n    nodeMap.set(nodeKey, nodeValue);\n  });\n  return [nodeMap, edgeMap];\n}\n\nexport function transformNodes(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitNode = undefined,\n  } = {},\n) {\n  const [nodeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitNode: visitNode,\n  });\n  return nodeMap;\n}\n\nexport function transformEdges(\n  nodes,\n  {\n    getNodeParents = undefined,\n    getNodeKey = undefined,\n    visitEdge = undefined,\n  } = {},\n) {\n  const [, edgeMap] = transform(nodes, {\n    getNodeParents: getNodeParents,\n    getNodeKey: getNodeKey,\n    visitEdge: visitEdge,\n  });\n  return edgeMap;\n}\n","import * as daglet from './daglet';\nimport * as tf from './tfjs';\nimport React from 'react';\nimport { required } from './utils';\n\nexport const DEFAULT_GRAVITY = 10;\n\nexport default class Scene {\n  constructor({\n    decals = [],\n    frames = [],\n    springs = [],\n    constraints = [],\n    gravity = DEFAULT_GRAVITY,\n  } = {}) {\n    this.decals = decals;\n    this.frames = frames;\n    this.springs = springs;\n    this.constraints = constraints;\n    this.gravity = gravity;\n\n    const getFrameChildren = (frame) => frame.frames;\n    const getFrameId = (frame) => frame.id;\n    this.sortedFrames = daglet\n      .toposort(this.frames, {\n        getNodeParents: getFrameChildren,\n        getNodeKey: getFrameId,\n      })\n      .reverse();\n    this.frameMap = new Map(\n      this.sortedFrames.map((frame) => [frame.id, frame]),\n    );\n    const frameIdParentsMap = daglet.getChildMap(this.sortedFrames, {\n      getNodeParents: getFrameChildren,\n      getNodeKey: getFrameId,\n    });\n    if ([...frameIdParentsMap.values()].some((parents) => parents.size > 1)) {\n      throw new Error('Frames should only have one parent'); // TODO: use AssertionError?\n    }\n    this.frameIdParentMap = new Map(\n      [...frameIdParentsMap].map(([frameId, parents]) => [\n        frameId,\n        parents.size ? [...parents][0].id : null,\n      ]),\n    );\n    this.frameIdPathMap = daglet.transformNodes(this.sortedFrames, {\n      getNodeParents: (frame) => [...frameIdParentsMap.get(frame.id)],\n      getNodeKey: getFrameId,\n      visitNode: (frame, parentPaths) =>\n        parentPaths.length ? [...parentPaths[0], frame.id] : [frame.id],\n    });\n  }\n\n  getDomElement(\n    stateMap = required('stateMap'),\n    xformMatrix = tf.eye(3),\n    { key = undefined } = {},\n  ) {\n    return (\n      <g className=\"scene\" key={key}>\n        {this.decals.map((decal, index) =>\n          decal.getDomElement(xformMatrix, { key: 'decal' + index }),\n        )}\n        {this.frames.map((frame, index) =>\n          frame.getDomElement(stateMap, xformMatrix, { key: 'frame' + index }),\n        )}\n      </g>\n    );\n  }\n\n  getInitialStateMap({ randomize = false } = {}) {\n    let getInitialState;\n    if (randomize) {\n      const randPi = () => (Math.random() - 0.5) * Math.PI * 2; // TBD\n      getInitialState = (frame) => [randPi(), randPi()];\n    } else {\n      getInitialState = (frame) => frame.initialState;\n    }\n    return new Map(\n      this.sortedFrames.map((frame) => [frame.id, getInitialState(frame)]),\n    );\n  }\n}\n","import * as tf from './tfjs';\nimport { invertXformMatrix } from './utils';\nimport { NotImplementedError } from './utils';\nimport { required } from './utils';\nimport { solveLinearSystem } from './utils';\n\nexport default class Solver {\n  constructor(scene = required('scene')) {\n    this.scene = scene;\n  }\n\n  _makeStateMap(qs = required('qs'), qds = required('qds')) {\n    return new Map(\n      this.scene.sortedFrames.map((frame, index) => [\n        frame.id,\n        [qs[index], qds[index]],\n      ]),\n    );\n  }\n\n  _getPosMatMap(stateMap = required('stateMap')) {\n    /**\n     * Determine all the local->global position transformation matrices,\n     * indexed by frame.\n     */\n    const posMatMap = new Map();\n    for (let frame of this.scene.sortedFrames) {\n      const [q] = stateMap.get(frame.id);\n      const parentId = this.scene.frameIdParentMap.get(frame.id);\n      let mat = frame.getPosMatrix(q);\n      if (parentId) {\n        mat = posMatMap.get(parentId).matMul(mat);\n      }\n      posMatMap.set(frame.id, mat);\n    }\n    return posMatMap;\n  }\n\n  _getInvPosMatMap(posMatMap = required('posMatMap')) {\n    /**\n     * Determine all the global->local (\"inverse\") position transformation\n     * matrices, indexed by frame.\n     */\n    return new Map(\n      [...posMatMap].map(([frameId, posMat]) => [\n        frameId,\n        invertXformMatrix(posMat),\n      ]),\n    );\n  }\n\n  _getVelMatMap(\n    posMatMap = required('posMatMap'),\n    invPosMatMap = required('invPosMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    /**\n     * Determine all the global position -> global velocity transformation\n     * matrices, indexed by frame, where each matrix represents the velocity\n     * field of the corresponding frame in global coordinates, such that\n     * right-multiplying the matrix by a global position vector yields a global\n     * velocity vector.\n     */\n    return new Map(\n      this.scene.sortedFrames.map((frame) => {\n        const [q] = stateMap.get(frame.id);\n        const parentId = this.scene.frameIdParentMap.get(frame.id);\n        let mat = frame.getVelMatrix(q).matMul(invPosMatMap.get(frame.id));\n        if (parentId) {\n          mat = posMatMap.get(parentId).matMul(mat);\n        }\n        return [frame.id, mat];\n      }),\n    );\n  }\n\n  _getAccelMatMap(\n    posMatMap = required('posMatMap'),\n    invPosMatMap = required('invPosMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    /**\n     * Global position -> global acceleration, indexed by frame, where each\n     * matrix represents the acceleration field of the corresponding frame in\n     * global coordinates.\n     */\n    return new Map(\n      this.scene.sortedFrames.map((frame) => {\n        const [q] = stateMap.get(frame.id);\n        const parentId = this.scene.frameIdParentMap.get(frame.id);\n        let mat = frame.getAccelMatrix(q).matMul(invPosMatMap.get(frame.id));\n        if (parentId) {\n          mat = posMatMap.get(parentId).matMul(mat);\n        }\n        return [frame.id, mat];\n      }),\n    );\n  }\n\n  _getVelSumMatMap(\n    posMatMap = required('posMatMap'),\n    velMatMap = required('velMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    const velSumMatMap = new Map();\n    for (let frame of this.scene.sortedFrames) {\n      const [, qd] = stateMap.get(frame.id);\n      const parentId = this.scene.frameIdParentMap.get(frame.id);\n      let mat = velMatMap.get(frame.id).mul(qd);\n      if (parentId) {\n        mat = mat.add(velSumMatMap.get(parentId));\n      }\n      velSumMatMap.set(frame.id, mat);\n    }\n    return velSumMatMap;\n  }\n\n  _getAccelSumMatMap(\n    posMatMap = required('posMatMap'),\n    velMatMap = required('velMatMap'),\n    accelMatMap = required('accelMatMap'),\n    velSumMatMap = required('velSumMatMap'),\n    stateMap = required('stateMap'),\n  ) {\n    const accelSumMatMap = new Map();\n    for (let frame of this.scene.sortedFrames) {\n      const [, qd] = stateMap.get(frame.id);\n      const parentId = this.scene.frameIdParentMap.get(frame.id);\n      let mat = accelMatMap.get(frame.id).mul(qd * qd);\n      if (parentId) {\n        const parentAccelSumMat = accelSumMatMap.get(parentId);\n        const parentVelSumMat = velSumMatMap.get(parentId);\n        const velMat = velMatMap.get(frame.id);\n        mat = mat\n          .add(parentAccelSumMat)\n          .add(parentVelSumMat.matMul(velMat).mul(2 * qd));\n      }\n      accelSumMatMap.set(frame.id, mat);\n    }\n    return accelSumMatMap;\n  }\n\n  _getWeightPosMap(posMatMap = required('posMatMap')) {\n    /**\n     * Transform all the weight positions of all the frames into global\n     * positions, indexed by frame and mass reference.\n     */\n    return new Map(\n      this.scene.sortedFrames.map((frame) => [\n        frame.id,\n        frame.weights.map((weight) =>\n          posMatMap.get(frame.id).matMul(weight.position),\n        ),\n      ]),\n    );\n  }\n\n  _isFrameDescendent(\n    descendentFrame = required('descendentFrame'),\n    ancestorFrame = required('ancestorFrame'),\n  ) {\n    return (\n      this.scene.frameIdPathMap\n        .get(descendentFrame.id)\n        .indexOf(ancestorFrame.id) !== -1\n    );\n  }\n\n  _getDescendentFrame(\n    frame1 = required('frame1'),\n    frame2 = required('frame2'),\n  ) {\n    let descendent;\n    if (this._isFrameDescendent(frame1, frame2)) {\n      descendent = frame1;\n    } else if (this._isFrameDescendent(frame2, frame1)) {\n      descendent = frame2;\n    } else {\n      descendent = null;\n    }\n    return descendent;\n  }\n\n  _getDescendentFrames(ancestorFrame = required('ancestorFrame')) {\n    return this.scene.sortedFrames.filter((frame) =>\n      this._isFrameDescendent(frame, ancestorFrame),\n    );\n  }\n\n  _getCoefficientMatrixEntry(\n    rowIndex = required('rowIndex'),\n    colIndex = required('colIndex'),\n    velMatMap = required('velMatMap'),\n    weightPosMap = required('weightPosMap'),\n  ) {\n    const frame1 = this.scene.sortedFrames[rowIndex];\n    const frame2 = this.scene.sortedFrames[colIndex];\n    const velMat1 = velMatMap.get(frame1.id);\n    const velMat2 = velMatMap.get(frame2.id);\n    const baseFrame = this._getDescendentFrame(frame1, frame2);\n    const descendentFrames = baseFrame\n      ? this._getDescendentFrames(baseFrame)\n      : [];\n    let result = 0;\n    for (let frame3 of descendentFrames) {\n      for (let index = 0; index < frame3.weights.length; index++) {\n        const weight = frame3.weights[index];\n        const pos = weightPosMap.get(frame3.id)[index];\n        result +=\n          weight.mass *\n          tf\n            .matMul(velMat2.matMul(pos), velMat1.matMul(pos), true)\n            .dataSync()[0];\n      }\n    }\n    return result;\n  }\n\n  _getCoefficientMatrix(\n    velMatMap = required('velMatMap'),\n    weightPosMap = required('weightPosMap'),\n  ) {\n    const numFrames = this.scene.sortedFrames.length;\n    const array = Array(numFrames);\n    for (let rowIndex = 0; rowIndex < numFrames; rowIndex++) {\n      const columns = Array(numFrames);\n      for (let colIndex = 0; colIndex < numFrames; colIndex++) {\n        columns[colIndex] = this._getCoefficientMatrixEntry(\n          rowIndex,\n          colIndex,\n          velMatMap,\n          weightPosMap,\n        );\n      }\n      array[rowIndex] = columns;\n    }\n    return tf.tensor2d(array);\n  }\n\n  _getForceVectorEntry(\n    baseFrame = required('baseFrame'),\n    velMatMap = required('velMatMap'),\n    velSumMatMap = required('velSumMatMap'),\n    accelSumMatMap = required('accelSumMatMap'),\n    weightPosMap = required('weightPosMap'),\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    let result = 0;\n    const baseVelMat = velMatMap.get(baseFrame.id);\n    for (let childFrame of this._getDescendentFrames(baseFrame)) {\n      const childVelSumMat = velSumMatMap.get(childFrame.id);\n      const childAccelSumMat = accelSumMatMap.get(childFrame.id);\n      for (\n        let weightIndex = 0;\n        weightIndex < childFrame.weights.length;\n        weightIndex++\n      ) {\n        const weight = childFrame.weights[weightIndex];\n        const weightPos = weightPosMap.get(childFrame.id)[weightIndex];\n        const weightBaseVel = baseVelMat.matMul(weightPos);\n        const weightChildVelSum = childVelSumMat.matMul(weightPos);\n        const weightChildAccelSum = childAccelSumMat.matMul(weightPos);\n        const kineticForce =\n          -weight.mass *\n          weightBaseVel.matMul(weightChildAccelSum, true).dataSync()[0];\n        const gravityForce =\n          -weight.mass * this.scene.gravity * weightBaseVel.dataSync()[1];\n        const dragForce =\n          -weight.drag *\n          weightBaseVel.matMul(weightChildVelSum, true).dataSync()[0];\n        result = kineticForce + dragForce + gravityForce;\n      }\n      const [, qd] = stateMap.get(baseFrame.id);\n      const resistanceForce = -baseFrame.resistance * qd;\n      const externalForce =\n        (externalForceMap && externalForceMap.get(baseFrame.id)) || 0;\n      result += externalForce + resistanceForce;\n    }\n    return result;\n  }\n\n  _getForceVector(\n    velMatMap = required('velMatMap'),\n    velSumMatMap = required('velSumMatMap'),\n    accelSumMatMap = required('accelSumMatMap'),\n    weightPosMap = required('weightPosMap'),\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const numFrames = this.scene.sortedFrames.length;\n    const array = Array(numFrames);\n    for (let index = 0; index < numFrames; index++) {\n      array[index] = this._getForceVectorEntry(\n        this.scene.sortedFrames[index],\n        velMatMap,\n        velSumMatMap,\n        accelSumMatMap,\n        weightPosMap,\n        stateMap,\n        externalForceMap,\n      );\n    }\n    return tf.tensor1d(array).reshape([numFrames, 1]);\n  }\n\n  _getSystemOfEquations(\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const posMatMap = this._getPosMatMap(stateMap);\n    const invPosMatMap = this._getInvPosMatMap(posMatMap);\n    const velMatMap = this._getVelMatMap(posMatMap, invPosMatMap, stateMap);\n    const accelMatMap = this._getAccelMatMap(posMatMap, invPosMatMap, stateMap);\n    const velSumMatMap = this._getVelSumMatMap(posMatMap, velMatMap, stateMap);\n    const accelSumMatMap = this._getAccelSumMatMap(\n      posMatMap,\n      velMatMap,\n      accelMatMap,\n      velSumMatMap,\n      stateMap,\n    );\n    const weightPosMap = this._getWeightPosMap(posMatMap);\n    const aMat = this._getCoefficientMatrix(velMatMap, weightPosMap);\n    const bVec = this._getForceVector(\n      velMatMap,\n      velSumMatMap,\n      accelSumMatMap,\n      weightPosMap,\n      stateMap,\n      externalForceMap,\n    );\n    return [aMat, bVec];\n  }\n\n  _solve(\n    stateMap = required('stateMap'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const [aMat, bVec] = this._getSystemOfEquations(stateMap, externalForceMap);\n    return solveLinearSystem(aMat, bVec, { asTensor: false });\n  }\n\n  _applyDeltas(\n    stateMap = required('stateMap'),\n    qddArray = required('qddArray'),\n    deltaTime = required('deltaTime'),\n  ) {\n    const newStateMap = new Map();\n    for (let index = 0; index < this.scene.sortedFrames.length; index++) {\n      const frame = this.scene.sortedFrames[index];\n      const qdd = qddArray[index];\n      const [q, qd] = stateMap.get(frame.id);\n      const newQ = q + qd * deltaTime;\n      const newQd = qd + qdd * deltaTime;\n      newStateMap.set(frame.id, [newQ, newQd]);\n    }\n    return newStateMap;\n  }\n\n  _tickSimple(\n    stateMap = required('stateMap'),\n    deltaTime = required('deltaTime'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    const qddArray = this._solve(stateMap, externalForceMap);\n    return this._applyDeltas(stateMap, qddArray, deltaTime);\n  }\n\n  _tickRungeKutta(\n    stateMap = required('stateMap'),\n    deltaTime = required('deltaTime'),\n    externalForceMap = required('externalForceMap'),\n  ) {\n    throw new NotImplementedError(\n      'Runge-Kutta tick functionality not implemented yet',\n    );\n  }\n\n  tick(\n    stateMap = required('stateMap'),\n    deltaTime = required('deltaTime'),\n    externalForceMap = null,\n    { rungeKutta = false } = {},\n  ) {\n    const doTick = rungeKutta ? this._tickRungeKutta : this._tickSimple;\n    return doTick.bind(this)(stateMap, deltaTime, externalForceMap);\n  }\n}\n","import * as tf from './tfjs';\nimport Frame from './Frame';\nimport { getTranslationMatrix } from './utils';\nimport { getXformMatrixRotationAngle } from './utils';\nimport { required } from './utils';\nimport { ZERO_POS } from './utils';\nimport { ZERO_STATE } from './utils';\n\nexport default class TrackFrame extends Frame {\n  constructor({\n    position = ZERO_POS,\n    angle = 0,\n    decals = [],\n    weights = [],\n    frames = [],\n    resistance = 0,\n    initialState = ZERO_STATE,\n    id = undefined,\n  } = {}) {\n    super({\n      angle: angle,\n      decals: decals,\n      weights: weights,\n      frames: frames,\n      resistance: resistance,\n      initialState: initialState,\n      position: position,\n      id: id,\n    });\n    this.angle = angle;\n  }\n\n  xform(\n    xformMatrix = required('xformMatrix'),\n    { decals = undefined, weights = undefined, frames = undefined } = {},\n  ) {\n    return new TrackFrame({\n      position: xformMatrix.matMul(this.position),\n      angle: this.angle + getXformMatrixRotationAngle(xformMatrix),\n      decals: decals != null ? decals : this.decals,\n      weights: weights != null ? weights : this.weights,\n      frames: frames != null ? frames : this.frames,\n      resistance: this.resistance,\n      initialState: this.initialState,\n    });\n  }\n\n  getPosMatrix(q = required('q')) {\n    const position = this.position.dataSync();\n    return getTranslationMatrix([\n      position[0] + q * Math.cos(this.angle),\n      position[1] + q * Math.sin(this.angle),\n    ]);\n  }\n\n  getVelMatrix(q = required('q')) {\n    return tf.tensor2d([\n      [0, 0, Math.cos(this.angle)],\n      [0, 0, Math.sin(this.angle)],\n      [0, 0, 0],\n    ]);\n  }\n}\n","import { coercePositionVector } from './utils';\nimport { ZERO_POS } from './utils';\n\nexport default class Weight {\n  constructor(mass = 1, { position = ZERO_POS, drag = 0 } = {}) {\n    this.mass = mass;\n    this.position = coercePositionVector(position);\n    this.drag = drag;\n  }\n\n  xform(xformMatrix) {\n    return new Weight({\n      mass: this.mass,\n      position: xformMatrix.matMul(this.position),\n      drag: this.drag,\n    });\n  }\n}\n","import './App.css';\nimport 'normalize.css';\nimport BoxDecal from './BoxDecal';\nimport CircleDecal from './CircleDecal';\nimport LineDecal from './LineDecal';\nimport producer from 'immer';\nimport React from 'react';\nimport RotationalFrame from './RotationalFrame';\nimport Scene from './Scene';\nimport Solver from './Solver';\nimport TrackFrame from './TrackFrame';\nimport Weight from './Weight';\nimport { getScaleMatrix } from './utils';\nimport { getTranslationMatrix } from './utils';\nimport { useEffect } from 'react';\nimport { useRef } from 'react';\nimport { useState } from 'react';\n\nconst pendulum1Length = 5;\nconst pendulum2Length = 5;\n\nconst pendulum2 = new RotationalFrame({\n  id: 'pendulum2',\n  initialState: [0, 0],\n  decals: [\n    new LineDecal({ endPos: [pendulum2Length, 0], lineWidth: 0.2 }),\n    new CircleDecal({\n      position: [pendulum2Length, 0],\n      radius: 1,\n      //color: 'green',\n    }),\n  ],\n  position: [pendulum1Length, 0],\n  weights: [new Weight(10, { position: [pendulum2Length, 0] })],\n  resistance: 4,\n});\n\nconst pendulum1 = new RotationalFrame({\n  id: 'pendulum1',\n  initialState: [Math.PI * -0.3, 0],\n  decals: [\n    new LineDecal({ endPos: [pendulum1Length, 0], lineWidth: 0.2 }),\n    new CircleDecal({\n      position: [pendulum1Length, 0],\n      radius: 1,\n    }),\n  ],\n  frames: [pendulum2],\n  weights: [new Weight(5, { position: [pendulum1Length, 0] })],\n  resistance: 4,\n});\n\nconst cart = new TrackFrame({\n  id: 'cart',\n  decals: [\n    new BoxDecal({\n      width: 3,\n      height: 3 / 1.618,\n      //color: 'blue',\n      lineWidth: 0.2,\n    }),\n  ],\n  frames: [pendulum1],\n  weights: [new Weight(100)],\n  resistance: 10,\n});\n\nconst scene = new Scene({\n  frames: [cart],\n  decals: [\n    new LineDecal({\n      startPos: [-300, 0],\n      endPos: [300, 0],\n      color: 'gray',\n      lineWidth: 0.1,\n    }),\n  ],\n});\nconst solver = new Solver(scene);\n\nfunction useKeyboard(callback) {\n  const [pressedKeys, setPressedKeys] = useState(new Set());\n  const callbackRef = useRef();\n  callbackRef.current = callback;\n\n  useEffect(() => {\n    function handleKeyDown({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (!pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.add(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: true,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n    function handleKeyUp({ code, keyCode }) {\n      setPressedKeys((pressedKeys) => {\n        if (pressedKeys.has(code)) {\n          pressedKeys = producer(pressedKeys, (draft) => {\n            draft.delete(code);\n          });\n          callbackRef.current &&\n            callbackRef.current({\n              keyName: code,\n              keyId: keyCode,\n              pressed: false,\n            });\n        }\n        return pressedKeys;\n      });\n    }\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n\n  return pressedKeys;\n}\n\nconst useAnimationFrame = (callback, params) => {\n  const fps = (params && params.fps) || 60;\n  const state = React.useRef({ prevTime: 0 });\n  const requestRef = React.useRef();\n  const timerRef = React.useRef();\n  state.current.callback = callback;\n\n  React.useEffect(() => {\n    function animate(time) {\n      const deltaTime = (time - state.current.prevTime) / 1000;\n      state.current.callback(deltaTime);\n      state.current.prevTime = time;\n      timerRef.current = setTimeout(() => {\n        requestRef.current = requestAnimationFrame(animate);\n      }, 1000 / fps - deltaTime);\n    }\n\n    requestRef.current = requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n      timerRef.current && clearTimeout(timerRef.current);\n    };\n  }, [fps]);\n};\n\nfunction isValidStateMap(stateMap) {\n  return [...stateMap].every(([frameId, [q, qd]]) => !isNaN(q) && !isNaN(qd));\n}\n\nfunction App() {\n  const [[translationX, translationY], setTranslation] = useState([300, 300]);\n  const [scale, setScale] = useState(15);\n  const pressedKeys = useKeyboard();\n  const xformMatrix = getTranslationMatrix([translationX, translationY]).matMul(\n    getScaleMatrix(scale, -scale),\n  );\n  const [stateMap, setStateMap] = useState(scene.getInitialStateMap());\n\n  useAnimationFrame((deltaTime) => {\n    let cartForce = 0;\n    Object.entries({\n      KeyA: () => {\n        cartForce -= 2000;\n      },\n      KeyD: () => {\n        cartForce += 2000;\n      },\n      Minus: () => setScale(scale * Math.exp(-deltaTime)),\n      Equal: () => setScale(scale * Math.exp(deltaTime)),\n      ArrowLeft: () => setTranslation(([x, y]) => [x + deltaTime * 150, y]),\n      ArrowRight: () => setTranslation(([x, y]) => [x - deltaTime * 150, y]),\n      ArrowUp: () => setTranslation(([x, y]) => [x, y + deltaTime * 150]),\n      ArrowDown: () => setTranslation(([x, y]) => [x, y - deltaTime * 150]),\n    }).forEach(([keyName, func]) => pressedKeys.has(keyName) && func());\n    const externalForceMap = new Map([[cart.id, cartForce]]);\n    let newStateMap = stateMap;\n    for (let i = 0; i < 10; i++) {\n      newStateMap = solver.tick(newStateMap, deltaTime / 10, externalForceMap);\n    }\n    if (!isValidStateMap(newStateMap)) {\n      console.warn(\n        'Encountered invalid state map; resetting to initial state...',\n      );\n      newStateMap = scene.getInitialStateMap();\n    }\n    setStateMap(newStateMap);\n  });\n\n  return (\n    <div className=\"app__main\">\n      <div className=\"plot\">\n        <h2 className=\"plot__title\">PoiBot</h2>\n        {\n          //<p>Keys: {[...pressedKeys].join(', ')}</p>\n        }\n        {\n          //<p>Scale: {scale.toFixed(2)}</p>\n        }\n        <div className=\"plot__main\">\n          <svg className=\"plot__svg\">\n            {scene.getDomElement(stateMap, xformMatrix)}\n          </svg>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import './index.css';\nimport * as immer from 'immer';\nimport * as serviceWorker from './serviceWorker';\nimport * as tf from '@tensorflow/tfjs';\nimport App from './App';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\ntf.setBackend('cpu');\nimmer.enableMapSet();\n\nwindow.tf = tf; // (for debugging)\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}